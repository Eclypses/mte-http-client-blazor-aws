// Copyright (c) Eclypses, Inc.
//
// All rights reserved.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

/** Status. */
export enum MteStatus {
/** Copyright (c) Eclypses, Inc. */
/**  */
/** All rights reserved. */
/**  */
/** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS */
/** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF */
/** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */
/** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY */
/** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, */
/** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE */
/** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */

/** WARNING: This file is automatically generated. Do not edit. */



/** Status codes. */
 

  /** No error occurred. */
  mte_status_success,

  /** Invalid input. */
  mte_status_invalid_input,

  /** Unsupported operation. */
  mte_status_unsupported,

  /** A normal DRBG error occurred. NIST SP 800-90A section 9. */
  mte_status_drbg_error,

  /** A catastrophic DRBG error occurred. NIST SP 800-90A section 9. */
  mte_status_drbg_catastrophic,

  /** The seedlife has been reached. NIST SP 800-90A section 9.3.1. */
  mte_status_drbg_seedlife_reached,

  /** A cipher algorithm self-test failed. */
  mte_status_cipher_test_failed,

  /** A hash algorithm self-test failed. */
  mte_status_hash_test_failed,

  /** Output is inhibited due to an error state or self-test. */
  mte_status_output_inhibited,

  /** Implementation error. */
  mte_status_impl_error,

  /** License error. */
  mte_status_license_error,

  /** No such token exists. */
  mte_status_token_does_not_exist,

  /** Checksum mismatch. */
  mte_status_checksum_mismatch,

  /** Hash digest mismatch. */
  mte_status_digest_mismatch,

  /** The message was received too long before/after it was sent. */
  mte_status_time_before_exceeded,
  mte_status_time_after_exceeded,

  /** The sequence number is outside the window. */
  mte_status_seq_outside_window,

  /** The sequence number has already been seen in async mode. */
  mte_status_seq_async_replay,

  /** Attempting to sync up a sequencing variation resulted in a bad */
  /** message. The state has been rolled back to where it was before the */
  /** message arrived. */
  mte_status_seq_mismatch
 



}

/** DRBGs. */
export enum MteDrbgs {
/** Copyright (c) Eclypses, Inc. */
/**  */
/** All rights reserved. */
/**  */
/** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS */
/** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF */
/** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */
/** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY */
/** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, */
/** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE */
/** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */

/** WARNING: This file is automatically generated. Do not edit. */



/** Deterministic Random Bit Generator algorithms. */
 

  /** None. An external DRBG must be provided instead. */
  mte_drbgs_none,

  /** Increment. The next "random" number is one more than the previous. */
  /** This provides no security and is meant for testing only. */
  mte_drbgs_increment,

  /** NIST CTR DRBG using AES-128 with derivation function. */
  mte_drbgs_ctr_aes128_df,

  /** NIST CTR DRBG using AES-128 with no derivation function. */
  mte_drbgs_ctr_aes128_nodf,

  /** NIST CTR DRBG using AES-192 with derivation function. */
  mte_drbgs_ctr_aes192_df,

  /** NIST CTR DRBG using AES-192 with no derivation function. */
  mte_drbgs_ctr_aes192_nodf,

  /** NIST CTR DRBG using AES-256 with derivation function. */
  mte_drbgs_ctr_aes256_df,

  /** NIST CTR DRBG using AES-256 with no derivation function. */
  mte_drbgs_ctr_aes256_nodf,

  /** NIST Hash DRBG using SHA-1. */
  mte_drbgs_hash_sha1,

  /** NIST Hash DRBG using SHA-256. */
  mte_drbgs_hash_sha256,

  /** NIST Hash DRBG using SHA-512. */
  mte_drbgs_hash_sha512
 



}

/** Verifiers. */
export enum MteVerifiers {
/** Copyright (c) Eclypses, Inc. */
/**  */
/** All rights reserved. */
/**  */
/** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS */
/** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF */
/** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */
/** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY */
/** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, */
/** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE */
/** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */

/** WARNING: This file is automatically generated. Do not edit. */



/** Message verifiers. */
 

  /** None. */
  mte_verifiers_none,

  /** CRC-32 checksum of data. */
  mte_verifiers_crc32,

  /** CRC-32 checksum of data and sequencing. */
  mte_verifiers_crc32_seq,

  /** Sequencing. */
  mte_verifiers_seq,

  /** 64-bit timestamp. */
  mte_verifiers_t64,

  /** 64-bit timestamp and CRC-32 checksum of data and timestamp. */
  mte_verifiers_t64_crc32,

  /** 64-bit timestamp, CRC-32 checksum of data and timestamp, and */
  /** sequencing. */
  mte_verifiers_t64_crc32_seq,

  /** 64-bit timestamp and sequencing. */
  mte_verifiers_t64_seq
 




}

/** Ciphers. */
export enum MteCiphers {
/** Copyright (c) Eclypses, Inc. */
/**  */
/** All rights reserved. */
/**  */
/** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS */
/** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF */
/** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */
/** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY */
/** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, */
/** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE */
/** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */

/** WARNING: This file is automatically generated. Do not edit. */



/** Cipher algorithms. */
 

  /** None. An external cipher must be provided instead. */
  mte_ciphers_none,

  /** AES-128-CTR. */
  mte_ciphers_aes128_ctr,

  /** AES-192-CTR. */
  mte_ciphers_aes192_ctr,

  /** AES-256-CTR. */
  mte_ciphers_aes256_ctr

 



}

/** Hashes. */
export enum MteHashes {
/** Copyright (c) Eclypses, Inc. */
/**  */
/** All rights reserved. */
/**  */
/** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS */
/** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF */
/** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */
/** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY */
/** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, */
/** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE */
/** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */

/** WARNING: This file is automatically generated. Do not edit. */



/** Hash algorithms. */
 

  /** None. An external hash may be provided instead. */
  mte_hashes_none,

  /** CRC-32 */
  mte_hashes_crc32,

  /** SHA-1 */
  mte_hashes_sha1,

  /** SHA-256 */
  mte_hashes_sha256,

  /** SHA-512 */
  mte_hashes_sha512
 



}

/** Init info. */
export enum MteInitInfo {
/** Copyright (c) Eclypses, Inc. */
/**  */
/** All rights reserved. */
/**  */
/** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS */
/** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF */
/** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */
/** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY */
/** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, */
/** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE */
/** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */

/** WARNING: This file is automatically generated. Do not edit. */



/** Init info requests. */
 

  /** ARM64: is the AES extension present? Return 0 if not or non-zero if */
  /**        it is. This is only requested if it wasn't able to be */
  /**        determined automatically. */
  mte_init_info_arm64_aes_paa,

  /** ARM64: is the SHA-1 extension present? Return 0 if not or non-zero */
  /**        if it is. This is only requested if it wasn't able to be */
  /**        determined automatically. */
  mte_init_info_arm64_sha1_paa,

  /** ARM64: is the SHA-256 extension present? Return 0 if not or non-zero */
  /**        if it is. This is only requested if it wasn't able to be */
  /**        determined automatically. */
  mte_init_info_arm64_sha256_paa,

  /** ARM64: is the SHA-512 extension present? Return 0 if not or non-zero */
  /**        if it is. This is only requested if it wasn't able to be */
  /**        determined automatically. */
  mte_init_info_arm64_sha512_paa,

  /** ARM64: is the CRC-32 extension present? Return 0 if not or non-zero */
  /**        if it is. This is only requested if it wasn't able to be */
  /**        determined automatically. */
  mte_init_info_arm64_crc32_paa
 



}

/** A byte array and status. */
export interface MteArrStatus {
  arr: Uint8Array | null;
  status: MteStatus;
}

/** A string and status. */
export interface MteStrStatus {
  str: string | null;
  status: MteStatus;
}

/** Common MTE functionality.
 *
 * To use, create an instance of a derived object, passing the WASM helper which
 * has been instantiated and the options. */
export class MteBase {
  /** Instances. */
  static readonly instances: MteBase[] = [];

  /** The WASM helper. */
  readonly wasm: MteWasm;
  readonly exports: MteWasmExports;
  readonly memory: WebAssembly.Memory;

  /** Instance index. */
  protected instance: number;

  /** Options. */
  private drbg: MteDrbgs = MteDrbgs.mte_drbgs_none;
  private tokBytes: number = 0;
  private verifiers: MteVerifiers = MteVerifiers.mte_verifiers_none;
  private cipher: MteCiphers = MteCiphers.mte_ciphers_none;
  private hash_: MteHashes = MteHashes.mte_hashes_none;

  /** Instantiation inputs. */
  private entropyInput: MteMem = new MteMem();
  private nonce: Uint8Array | null = null;

  /** Nonce length when set as an integer. */
  private nonceIntBytes: number = 0;

  /** Callback overrides. */
  private eiCallback: MteEntropyCallback | null = null;
  private nCallback: MteNonceCallback | null = null;
  private tsCallback: MteTimestampCallback | null = null;

  /** True if MTE is initialized or false if not. */
  private static mteInitialized: boolean = false;

  /** Constructor. Derived classes must call initBase() from their
      constructor. */
  constructor(wasm: MteWasm) {
    // Reference the WASM.
    this.wasm = wasm;
    if (wasm.exports !== null) {
      this.exports = wasm.exports;
    } else {
      throw new TypeError("MteBase: WASM does not have exports.");
    }
    if (wasm.memory !== null) {
      this.memory = wasm.memory;
    } else {
      throw new TypeError("MteBase: WASM does not have memory.");
    }

    // Set the WASM callbacks.
    if (wasm.entropyCallback === null) {
      wasm.entropyCallback = this.entropyCallback;
    }
    if (wasm.nonceCallback === null) {
      wasm.nonceCallback = this.nonceCallback;
    }
    if (wasm.timestampCallback === null) {
      wasm.timestampCallback = this.timestampCallback;
    }

    // Register the instance.
    this.instance = MteBase.instances.length;
    MteBase.instances.push(this);

    // Initialize MTE.
    if (!MteBase.mteInitialized) {
      // Do global init.
      if (this.exports.mte_init(0, 0) == 0) {
        throw new Error("MteBase: MTE init error.");
      }
    }
  }

  /** Initialize. Derived classes must call this from their constructor. */
  initBase = (drbg: MteDrbgs,
              tokBytes: number,
              verifiers: MteVerifiers,
              cipher: MteCiphers,
              hash_: MteHashes): void => {
    // Set options.
    this.drbg = drbg;
    this.tokBytes = tokBytes;
    this.verifiers = verifiers;
    this.cipher = cipher;
    this.hash_ = hash_;

    // The ideal nonce length is the size of the nonce integer, but it must be
    // at least the minimum for the DRBG and no more than the maximum for the
    // DRBG.
    this.nonceIntBytes = Math.max(this.getDrbgsNonceMinBytes(drbg),
                                  Math.min(8,
                                           this.getDrbgsNonceMaxBytes(drbg)));
  }

  /** Destruct. The WASM memory will be freed. Derived classes must call this
   *  from their destruct method. */
  destructBase = (): void => {
    this.wasm.free(this.entropyInput); this.entropyInput.invalidate();
  }

  /** Returns the MTE version number as a string or individual integer
   *  parts. */
  getVersion = (): string => {
    const off = this.exports.mte_base_version();
    return this.wasm.wasmOffToStr(off);
  }
  getVersionMajor = (): number => {
    return this.exports.mte_wasm_base_version_major();
  }
  getVersionMinor = (): number => {
    return this.exports.mte_wasm_base_version_minor();
  }
  getVersionPatch = (): number => {
    return this.exports.mte_wasm_base_version_patch();
  }

  /** Initialize with the company name and license code. Returns true if
   *  successful or false if not. If true is returned, MTE functions are usable;
   *  otherwise functions that return a status will return an error status. */
  initLicense = (company: string, license: string): boolean => {
    const wcompany = this.wasm.strToWasm(company);
    const wlicense = this.wasm.strToWasm(license);
    const ret = this.exports.mte_license_init(wcompany.off, wlicense.off);
    this.wasm.free(wcompany);
    this.wasm.free(wlicense);
    return ret;
  }

  /** Returns the count of status codes. */
  getStatusCount = (): number => {
    return this.exports.mte_wasm_base_status_count();
  }

  /** Returns the enumeration name for the given status. */
  getStatusName = (status_: MteStatus): string => {
    const off = this.exports.mte_wasm_base_status_name(status_);
    return this.wasm.wasmOffToStr(off);
  }

  /** Returns the description for the given status. */
  getStatusDescription = (status_: MteStatus): string => {
    const off = this.exports.mte_wasm_base_status_description(status_);
    return this.wasm.wasmOffToStr(off);
  }

  /** Returns the status code for the given enumeration name. */
  getStatusCode = (name: string): MteStatus => {
    const wname = this.wasm.strToWasm(name);
    const status_ = this.exports.mte_wasm_base_status_code(wname.off);
    this.wasm.free(wname);
    return status_;
  }

  /** Returns true if the status code is an error, false if it is success or a
   *  warning. */
  statusIsError = (status_: MteStatus): boolean => {
    return this.exports.mte_base_status_is_error(status_);
  }

  /** Returns true if runtime options are available or false if not. */
  hasRuntimeOpts = (): boolean => {
    return this.exports.mte_wasm_base_has_runtime_opts();
  }

  /** Returns the default DRBG. If runtime options are not available, this is
   *  the only option available; otherwise it is a suitable default. */
  getDefaultDrbg = (): MteDrbgs => {
    return this.exports.mte_wasm_base_default_drbg();
  }

  /** Returns the default token size. If runtime options are not available,
   *  this is the only option available; otherwise it is a suitable default. */
  getDefaultTokBytes = (): number => {
    return this.exports.mte_wasm_base_default_tok_bytes();
  }

  /** Returns the default verifiers. If runtime options are not available,
   *  this is the only option available; otherwise it is a suitable default. */
  getDefaultVerifiers = (): MteVerifiers => {
    return this.exports.mte_wasm_base_default_verifiers();
  }

  /** Returns the default cipher. If runtime options are not available, this is
   *  the only option available; otherwise it is a suitable default. */
  getDefaultCipher = (): MteCiphers => {
    return this.exports.mte_wasm_base_default_cipher();
  }

  /** Returns the default hash. If runtime options are not available, this is
   *  the only option available; otherwise it is a suitable default. */
  getDefaultHash = (): MteHashes => {
    return this.exports.mte_wasm_base_default_hash();
  }

  /** Returns the count of DRBG algorithms. */
  getDrbgsCount = (): number => {
    return this.exports.mte_wasm_base_drbgs_count();
  }

  /** Returns the enumeration name for the given algorithm. */
  getDrbgsName = (algo: MteDrbgs): string => {
    const off = this.exports.mte_wasm_base_drbgs_name(algo);
    return this.wasm.wasmOffToStr(off);
  }

  /** Returns the algorithm for the given enumeration name. */
  getDrbgsAlgo = (name: string): MteDrbgs => {
    const wname = this.wasm.strToWasm(name);
    const algo = this.exports.mte_wasm_base_drbgs_algo(wname.off);
    this.wasm.free(wname);
    return algo;
  }

  /** Returns the security strength for the given algorithm. */
  getDrbgsSecStrengthBytes = (algo: MteDrbgs): number => {
    return this.exports.mte_wasm_base_drbgs_sec_strength_bytes(algo);
  }

  /** Returns the minimum personalization string size for the given
   *  algorithm. */
  getDrbgsPersonalMinBytes = (algo: MteDrbgs): number => {
    return this.exports.mte_wasm_base_drbgs_personal_min_bytes(algo);
  }

  /** Returns the maximum personalization string size for the given
   *  algorithm. */
   getDrbgsPersonalMaxBytes = (algo: MteDrbgs): number => {
    return this.exports.mte_wasm_base_drbgs_personal_max_bytes(algo);
  }

  /** Returns the minimum entropy size for the given algorithm. */
  getDrbgsEntropyMinBytes = (algo: MteDrbgs): number => {
    return this.exports.mte_wasm_base_drbgs_entropy_min_bytes(algo);
  }

  /** Returns the maximum entropy size for the given algorithm. */
  getDrbgsEntropyMaxBytes = (algo: MteDrbgs): number => {
    return this.exports.mte_wasm_base_drbgs_entropy_max_bytes(algo);
  }

  /** Returns the minimum nonce size for the given algorithm. */
  getDrbgsNonceMinBytes = (algo: MteDrbgs): number => {
    return this.exports.mte_wasm_base_drbgs_nonce_min_bytes(algo);
  }

  /** Returns the maximum nonce size for the given algorithm. */
  getDrbgsNonceMaxBytes = (algo: MteDrbgs): number => {
    return this.exports.mte_wasm_base_drbgs_nonce_max_bytes(algo);
  }

  /** Returns the reseed interval for the given algorithm. */
  getDrbgsReseedInterval = (algo: MteDrbgs): number => {
    return this.exports.mte_wasm_base_drbgs_reseed_interval(algo);
  }

  /** Set the increment DRBG to return an error during instantiation and
   *  uninstantiation (if true) or not (if false). This is useful for testing
   *  error handling. The flag is false until set with this. */
  setIncrInstError = (flag: boolean): void => {
    this.exports.mte_wasm_base_drbgs_incr_inst_error(flag);
  }

  /** Set the increment DRBG to produce an error after the given number of
   *  values have been generated (if flag is true) or turn off errors (if flag
   *  is false) other than the reseed error, which is always produced when the
   *  seed interval is reached. The flag is false until set with this. */
  setIncrGenError = (flag: boolean, after: number): void => {
    this.exports.mte_wasm_base_drbgs_incr_gen_error(flag, after);
  }

  /** Returns the count of verifier algorithms. */
  getVerifiersCount = (): number => {
    return this.exports.mte_wasm_base_verifiers_count();
  }

  /** Returns the enumeration name for the given algorithm. */
  getVerifiersName = (algo: MteVerifiers): string => {
    const off = this.exports.mte_wasm_base_verifiers_name(algo);
    return this.wasm.wasmOffToStr(off);
  }

  /** Returns the algorithm for the given enumeration name. */
  getVerifiersAlgo = (name: string): MteVerifiers => {
    const wname = this.wasm.strToWasm(name);
    const algo = this.exports.mte_wasm_base_verifiers_algo(wname.off);
    this.wasm.free(wname);
    return algo;
  }

  /** Returns the count of cipher algorithms. */
  getCiphersCount = (): number => {
    return this.exports.mte_wasm_base_ciphers_count();
  }

  /** Returns the enumeration name for the given algorithm. */
  getCiphersName = (algo: MteCiphers): string => {
    // Get the name. Create an array overlaying the WASM memory starting at that
    // location. Convert to JS string.
    const off = this.exports.mte_wasm_base_ciphers_name(algo);
    return this.wasm.wasmOffToStr(off);
  }

  /** Returns the algorithm for the given enumeration name. */
  getCiphersAlgo = (name: string): MteCiphers => {
    // Convert the string to UTF-8 in WASM memory, get the algorithm, and free
    // the WASM memory.
    const wname = this.wasm.strToWasm(name);
    const algo = this.exports.mte_wasm_base_ciphers_algo(wname.off);
    this.wasm.free(wname);
    return algo;
  }

  /** Returns the block size for the given algorithm. */
  getCiphersBlockBytes = (algo: MteCiphers): number => {
    return this.exports.mte_wasm_base_ciphers_block_bytes(algo);
  }

  /** Returns the count of hash algorithms. */
  getHashesCount = (): number => {
    return this.exports.mte_wasm_base_hashes_count();
  }

  /** Returns the enumeration name for the given algorithm. */
  getHashesName = (algo: MteHashes): string => {
    // Get the name. Create an array overlaying the WASM memory starting at that
    // location. Convert to JS string.
    const off = this.exports.mte_wasm_base_hashes_name(algo);
    return this.wasm.wasmOffToStr(off);
  }

  /** Returns the algorithm for the given enumeration name. */
  getHashesAlgo = (name: string): MteHashes => {
    // Convert the string to UTF-8 in WASM memory, get the algorithm, and free
    // the WASM memory.
    const wname = this.wasm.strToWasm(name);
    const algo = this.exports.mte_wasm_base_hashes_algo(wname.off);
    this.wasm.free(wname);
    return algo;
  }

  /** Return the options in use. */
  getDrbg = (): MteDrbgs => {
    return this.drbg;
  }
  getTokBytes = (): number => {
    return this.tokBytes;
  }
  getVerifiers = (): MteVerifiers => {
    return this.verifiers;
  }
  getCipher = (): MteCiphers => {
    return this.cipher;
  }
  getHash = (): MteHashes => {
    return this.hash_;
  }

  /** Set the entropy callback. If not null, it is called to get entropy. If
   *  null, the entropy set with setEntropyArr(), setEntropyStr(), or
   *  setEntropyB64() is used. */
  setEntropyCallback = (cb: MteEntropyCallback | null): void => {
    this.eiCallback = cb;
  }

  /** Set the entropy input value. This must be done before calling
   *  an instantiation method that will trigger the entropy callback.
   *
   *  The entropy is zeroized immediately.
   *
   *  If the entropy callback is null, entropyInput is used as the entropy. */
  setEntropyArr = (entropyInput: Uint8Array): void => {
    // Copy to WASM memory.
    this.wasm.free(this.entropyInput);
    this.entropyInput = this.wasm.arrToWasm(entropyInput);

    // Zeroize.
    for (let i = 0; i < entropyInput.length; ++i) {
      entropyInput[i] = 0;
    }
  }

  /** Calls setEntropyArr() with the entropy converted to an array of bytes in
   *  UTF-8 encoding.
   *
   *  WARNING: the entropy is not zeroized because a 'string' object is read-
   *  only. */
  setEntropyStr = (entropyInput: string): void => {
    // Convert the string to UTF-8 in WASM memory.
    this.wasm.free(this.entropyInput);
    this.entropyInput = this.wasm.strToWasm(entropyInput);
  }

  /** Calls setEntropyArr() with the Base64-decoded version of entropyInput.
   *
   *  WARNING: the entropy is not zeroized because a 'string' object is read-
   *  only. */
  setEntropyB64 = (entropyInput: string): void => {
    // Decode Base64 in WASM memory. Set the decoded size.
    this.wasm.free(this.entropyInput);
    this.entropyInput = this.wasm.strToWasm(entropyInput);
    const bytes = this.exports.mte_wasm_base64_decode(this.entropyInput.off);
    this.entropyInput.used = bytes;
  }

  /** Set the nonce callback. If not null, it is called to get the nonce. If
   *  null, the nonce set with setNonceArr() or setNonce() is used. */
  setNonceCallback = (cb: MteNonceCallback | null): void => {
    this.nCallback = cb;
  }

  /** Set the nonce. This must be done before calling an instantiation method
   *  that will trigger the nonce callback.
   *
   *  If the nonce callback is null, it is used as the nonce. */
  setNonceArr = (nonce: Uint8Array): void => {
    this.nonce = nonce;
  }

  /** Calls setNonceArr() with the nonce interpreted as a 64-bit integer in
   *  decimal using the value as an array of bytes in little endian format. */
  setNonce = (nonce: string): void => {
    // Create an array of the ideal size, then convert the decimal string to
    // that array in little endian, supporting a full 64-bit range.
    const arr = new Uint8Array(this.nonceIntBytes);
    for (let i = 0; i < nonce.length; ++i) {
      let carry = parseInt(nonce.charAt(i));
      for (let j = 0; j < arr.length; ++j) {
        let digit = (arr[j] * 10) + carry;
        arr[j] = digit % 256;
        carry = Math.floor(digit / 256);
      }
    }

    // Set that array as the nonce.
    this.setNonceArr(arr);
  }

  /** Set the timestamp callback. If not null, it is called to get the
   *  timestamp. If null, 0 is used. */
  setTimestampCallback = (cb: MteTimestampCallback | null): void => {
    this.tsCallback = cb;
  }

  /** The entropy callback. */
  entropyCallback = (context: number,
                     minEntropy: number,
                     minLength: number,
                     maxLength: number,
                     entropyInput: number,
                     eiBytes: number): MteStatus => {
    // Get the MTE instance.
    const theThis = MteBase.instances[context];

    // Call the override callback if set.
    if (theThis.eiCallback) {
      return theThis.eiCallback.entropyCallback(minEntropy,
                                                minLength,
                                                maxLength,
                                                entropyInput,
                                                eiBytes);
    }

    // Check the length.
    if (theThis.entropyInput.used < minLength ||
        theThis.entropyInput.used > maxLength) {
      return MteStatus.mte_status_drbg_catastrophic;
    }

    // Point at the entropy in WASM memory.
    theThis.wasm.intToWasm(entropyInput, theThis.entropyInput.off);

    // Set the length.
    theThis.wasm.intToWasm(eiBytes, theThis.entropyInput.used);

    // Success.
    return MteStatus.mte_status_success;
  }

  /** The nonce callback. */
  nonceCallback = (context: number,
                   minLength: number,
                   maxLength: number,
                   nonce: number,
                   nBytes: number): void => {
    // Get the MTE instance.
    const theThis = MteBase.instances[context];

    // Call the override callback if set.
    if (theThis.nCallback) {
      theThis.nCallback.nonceCallback(minLength, maxLength, nonce, nBytes);
      return;
    }

    // Check that the nonce was set.
    if (theThis.nonce == null) {
      theThis.wasm.intToWasm(nBytes, 0);
      return;
    }

    // Copy the nonce to the WASM-provided buffer.
    this.wasm.arrToOffLen(theThis.nonce, nonce, theThis.nonce.length);

    // Set the length.
    theThis.wasm.intToWasm(nBytes, theThis.nonce.length);
  }

  /** Timestamp callback. */
  timestampCallback = (context: number, tsOff: number): void => {
    // Get the MTE instance.
    const theThis = MteBase.instances[context];

    // Call the override callback if set. Otherwise it defaults to 0.
    let ts = { ts: 0, upper: 0 };
    if (theThis.tsCallback) {
      ts = theThis.tsCallback.timestampCallback();
    }

    // Set the timestamp in WASM. If upper is zero, the entire timestamp is in
    // ts so copy as a 64-bit number.
    if (ts.upper == 0) {
      theThis.wasm.int64ToWasm(tsOff, ts.ts);
    }
    else {
      // Otherwise set the two 32-bit parts in to the 64-bit number.
      theThis.wasm.intToWasm(tsOff, ts.ts);
      theThis.wasm.intToWasm(tsOff + 4, ts.upper);
    }
  }
}

/** This is the MTE encoder.
 *
 *  To use, create an instance passing the WASM helper which has been
 *  instantiated. */
export class MteEnc extends MteBase {
  /** The encoder. */
  protected encoder: MteMem;

  /** Saved state buffers. */
  private saved: MteMem;
  private saved64: MteMem;

  /** Constructor taking the DRBG, token size in bytes, and verifiers
   *  algorithm. */
  constructor(wasm: MteWasm,
              drbg: MteDrbgs | string,
              tokBytes: number,
              verifiers: MteVerifiers | string) {
    // Super.
    super(wasm);

    // Get the DRBG and verifier as enums if they are strings.
    const drbgE = typeof drbg === "string" ?
      this.getDrbgsAlgo(drbg) : drbg;
    const verifiersE = typeof verifiers === "string" ?
      this.getVerifiersAlgo(verifiers) : verifiers;

    // Initialize the base.
    this.initBase(drbgE,
                  tokBytes,
                  verifiersE,
                  MteCiphers.mte_ciphers_none,
                  MteHashes.mte_hashes_none);

    // Get the encoder size.
    const bytes = this.exports.mte_wasm_enc_state_bytes(drbgE,
                                                        tokBytes,
                                                        verifiersE);
    if (bytes == 0) {
      throw new RangeError("MteEnc: Invalid options.");
    }

    // Allocate the encoder.
    this.encoder = wasm.malloc(bytes);

    // Initialize the encoder state.
    const stat = this.exports.mte_wasm_enc_state_init(this.encoder.off,
                                                      drbgE,
                                                      tokBytes,
                                                      verifiersE);
    if (stat != MteStatus.mte_status_success) {
      throw new RangeError("MteEnc: Invalid options.");
    }

    // Saved state.
    this.saved =
      wasm.malloc(this.exports.mte_enc_save_bytes(this.encoder.off));
    this.saved64 =
      wasm.malloc(this.exports.mte_wasm_enc_save_bytes_b64(this.encoder.off));
  }

  /** Create an encoder using default options. */
  public static fromdefault(wasm: MteWasm): MteEnc {
    const base = new MteBase(wasm);
    return new MteEnc(wasm,
                      base.getDefaultDrbg(),
                      base.getDefaultTokBytes(),
                      base.getDefaultVerifiers());
  }

  /** Destruct. The WASM memory will be freed and the object can no longer be
   *  used. */
  destruct = (): void => {
    this.destructBase();
    this.wasm.free(this.encoder); this.encoder.invalidate();
    this.wasm.free(this.saved); this.saved.invalidate();
    this.wasm.free(this.saved64); this.saved64.invalidate();
  }

  /** Instantiate the encoder with the personalization string. The entropy and
   *  nonce callbacks will be called to get the rest of the seeding material.
   *  Returns the status. */
  instantiate = (ps: string): MteStatus => {
    // Create the personalization string in WASM.
    const psWasm = this.wasm.strToWasm(ps);

    // Instantiate.
    const ret = this.exports.mte_wasm_enc_instantiate(this.encoder.off,
                                                      this.instance,
                                                      this.instance,
                                                      psWasm.off, psWasm.used);

    // Free the personalization string.
    this.wasm.free(psWasm);

    // Return the status.
    return ret;
  }

  /** Returns the reseed counter. */
  getReseedCounter = (): number => {
    return this.exports.mte_wasm_enc_reseed_counter(this.encoder.off);
  }

  /** Returns the saved state as a byte array. On error, null is returned. */
  saveState = (): Uint8Array | null => {
    // Save to the save memory. Return the buffer.
    const status = this.exports.mte_enc_state_save(this.encoder.off,
                                                   this.saved.off);
    return status == MteStatus.mte_status_success ?
      new Uint8Array(this.saved.buff!) : null;
  }

  /** Returns the saved state, Base64 encoded. On error, null is returned. */
   saveStateB64 = (): string | null => {
    // Save to the save memory. Return the Base64-encoded string.
    const status = this.exports.mte_wasm_enc_state_save_b64(this.encoder.off,
                                                            this.saved64.off);
    return status == MteStatus.mte_status_success ?
      this.wasm.wasmToStr(this.saved64) : null;
  }

  /** Restore a saved state, which must be the same length as was returned
   *  from the saveState() call. Returns the status. */
  restoreState = (saved: Uint8Array): MteStatus => {
    // Copy to the saved state buffer.
    this.wasm.arrToOffLen(saved, this.saved.off, saved.length);

    // Restore.
    return this.exports.mte_enc_state_restore(this.encoder.off, this.saved.off);
  }

  /** Restore a saved state, which must be the same length as was returned
   *  from the saveStateB64() call. Returns the status. */
   restoreStateB64 = (saved: string): MteStatus => {
    // Copy to the WASM memory.
    const stateWasm = this.wasm.strToWasm(saved);

    // Restore.
    const status = this.exports.mte_wasm_enc_state_restore_b64(this.encoder.off,
                                                               stateWasm.off);

    // Free the WASM memory.
    this.wasm.free(stateWasm);

    // Return status.
    return status;
  }

  /** Encode the given data. Returns the encoded version and status. */
  encode = (data: Uint8Array): MteArrStatus => {
    // Copy the data to the WASM memory.
    const wdata = this.wasm.arrToWasm(data);

    // Allocate the encoder buffers.
    const bytes = this.exports.mte_enc_buff_bytes(this.encoder.off,
                                                  data.length);
    const encBuff = this.wasm.malloc(bytes);
    const eOff = this.wasm.newInt();
    const eBytes = this.wasm.newInt();

    // Encode.
    const ret = this.exports.mte_wasm_enc_encode(this.encoder.off,
                                                 this.instance,
                                                 wdata.off, data.length,
                                                 encBuff.off,
                                                 eOff.off,
                                                 eBytes.off);
    if (ret != MteStatus.mte_status_success) {
      this.wasm.free(wdata);
      this.wasm.free(encBuff);
      this.wasm.free(eOff);
      this.wasm.free(eBytes);
      return { arr: null, status: ret };
    }

    // Copy the encoded data to an array.
    const encOff = this.wasm.wasmToInt(eOff.off);
    const encBytes = this.wasm.wasmToInt(eBytes.off);
    const encoded = encBuff.buff!.slice(encOff, encOff + encBytes);

    // Free the buffers.
    this.wasm.free(wdata);
    this.wasm.free(encBuff);
    this.wasm.free(eOff);
    this.wasm.free(eBytes);

    // Return the encoded version and status.
    return { arr: encoded, status: ret };
  }

  /** Encode the given data, Base64 encoded. Returns the encoded version and
   *  status. */
  encodeB64 = (data: Uint8Array): MteStrStatus => {
    // Copy the data to the WASM memory.
    const wdata = this.wasm.arrToWasm(data);

    // Allocate the encoder buffers.
    const bytes = this.exports.mte_wasm_enc_buff_bytes_b64(this.encoder.off,
                                                           data.length);
    const encBuff = this.wasm.malloc(bytes);
    const eOff = this.wasm.newInt();
    const eBytes = this.wasm.newInt();

    // Encode.
    const ret = this.exports.mte_wasm_enc_encode_b64(this.encoder.off,
                                                     this.instance,
                                                     wdata.off,
                                                     data.length,
                                                     encBuff.off,
                                                     eOff.off,
                                                     eBytes.off);
    if (ret != MteStatus.mte_status_success) {
      this.wasm.free(wdata);
      this.wasm.free(encBuff);
      this.wasm.free(eOff);
      this.wasm.free(eBytes);
      return { str: null, status: ret };
    }

    // Convert to string.
    const encOff = this.wasm.wasmToInt(eOff.off);
    const encoded = this.wasm.wasmToStr(encBuff, encOff);

    // Free the buffers.
    this.wasm.free(wdata);
    this.wasm.free(encBuff);
    this.wasm.free(eOff);
    this.wasm.free(eBytes);

    // Return the encoded version and status.
    return { str: encoded, status: ret };
  }

  /** Encode the given string. Returns the encoded message and status. */
  encodeStr = (str: string): MteArrStatus => {
    // Convert the string to the WASM memory.
    const wdata = this.wasm.strToWasm(str);

    // Allocate the encoder buffers.
    const bytes = this.exports.mte_enc_buff_bytes(this.encoder.off,
                                                  wdata.used);
    const encBuff = this.wasm.malloc(bytes);
    const eOff = this.wasm.newInt();
    const eBytes = this.wasm.newInt();

    // Encode.
    const ret = this.exports.mte_wasm_enc_encode(this.encoder.off,
                                                 this.instance,
                                                 wdata.off, wdata.used,
                                                 encBuff.off,
                                                 eOff.off,
                                                 eBytes.off);
    if (ret != MteStatus.mte_status_success) {
      this.wasm.free(wdata);
      this.wasm.free(encBuff);
      this.wasm.free(eOff);
      this.wasm.free(eBytes);
      return { arr: null, status: ret };
    }

    // Copy the encoded data to an array.
    const encOff = this.wasm.wasmToInt(eOff.off);
    const encBytes = this.wasm.wasmToInt(eBytes.off);
    const encoded = encBuff.buff!.slice(encOff, encOff + encBytes);

    // Free the buffers.
    this.wasm.free(wdata);
    this.wasm.free(encBuff);
    this.wasm.free(eOff);
    this.wasm.free(eBytes);

    // Return the encoded version and status.
    return { arr: encoded, status: ret };
  }

  /** Encode the given string, Base64 encoded. Returns the encoded message and
   *  status. */
  encodeStrB64 = (str: string): MteStrStatus => {
    // Convert the string to the WASM memory.
    const wdata = this.wasm.strToWasm(str);

    // Allocate the encoder buffers.
    const bytes = this.exports.mte_wasm_enc_buff_bytes_b64(this.encoder.off,
                                                           wdata.used);
    const encBuff = this.wasm.malloc(bytes);
    const eOff = this.wasm.newInt();
    const eBytes = this.wasm.newInt();

    // Encode.
    const ret = this.exports.mte_wasm_enc_encode_b64(this.encoder.off,
                                                     this.instance,
                                                     wdata.off,
                                                     wdata.used,
                                                     encBuff.off,
                                                     eOff.off,
                                                     eBytes.off);
    if (ret != MteStatus.mte_status_success) {
      this.wasm.free(wdata);
      this.wasm.free(encBuff);
      this.wasm.free(eOff);
      this.wasm.free(eBytes);
      return { str: null, status: ret };
    }

    // Convert to string.
    const encOff = this.wasm.wasmToInt(eOff.off);
    const encoded = this.wasm.wasmToStr(encBuff, encOff);

    // Free the buffers.
    this.wasm.free(wdata);
    this.wasm.free(encBuff);
    this.wasm.free(eOff);
    this.wasm.free(eBytes);

    // Return the encoded version and status.
    return { str: encoded, status: ret };
  }

  /** Uninstantiate. */
  uninstantiate = (): MteStatus => {
    return this.exports.mte_enc_uninstantiate(this.encoder.off);
  }
}

/** This is the MTE decoder.
 *
 *  To use, create an instance passing the WASM helper which has been
 *  instantiated. */
export class MteDec extends MteBase {
  /** The decoder. */
  protected decoder: MteMem;

  /** Saved state buffers. */
  private saved: MteMem;
  private saved64: MteMem;

  /** Decode values. */
  private encTs: MteTimestamp = { ts: 0, upper: 0 };
  private decTs: MteTimestamp = { ts: 0, upper: 0 };
  private msgSkipped: number = 0;

  /** Constructor taking the DRBG, token size in bytes, verifiers algorithm,
   *  timestamp window, and sequence window. */
  constructor(wasm: MteWasm,
              drbg: MteDrbgs | string,
              tokBytes: number,
              verifiers: MteVerifiers | string,
              tWindow: number,
              sWindow: number) {
    // Super.
    super(wasm);

    // Get the DRBG and verifier as enums if they are strings.
    const drbgE = typeof drbg === "string" ?
      this.getDrbgsAlgo(drbg) : drbg;
    const verifiersE = typeof verifiers === "string" ?
      this.getVerifiersAlgo(verifiers) : verifiers;

    // Initialize the base.
    this.initBase(drbgE,
                  tokBytes,
                  verifiersE,
                  MteCiphers.mte_ciphers_none,
                  MteHashes.mte_hashes_none);

    // Get the decoder size.
    const bytes = this.exports.mte_wasm_dec_state_bytes(drbgE,
                                                        tokBytes,
                                                        verifiersE);
    if (bytes == 0) {
      throw new RangeError("MteDec: Invalid options.");
    }

    // Allocate the decoder.
    this.decoder = wasm.malloc(bytes);

    // Initialize the decoder state.
    const stat = this.exports.mte_wasm_dec_state_init(this.decoder.off,
                                                      drbgE,
                                                      tokBytes,
                                                      verifiersE,
                                                      tWindow,
                                                      sWindow);
    if (stat != MteStatus.mte_status_success) {
      this.wasm.free(this.decoder);
      throw new RangeError("MteDec: Invalid options.");
    }

    // Saved state.
    this.saved =
      wasm.malloc(this.exports.mte_dec_save_bytes(this.decoder.off));
    this.saved64 =
      wasm.malloc(this.exports.mte_wasm_dec_save_bytes_b64(this.decoder.off));
  }

  /** Create a decoder using default options.
   *
   *  The timestamp window and sequence window are optionally settable. */
  public static fromdefault(wasm: MteWasm, tWindow = 0, sWindow = 0): MteDec {
    const base = new MteBase(wasm);
    return new MteDec(wasm,
                      base.getDefaultDrbg(),
                      base.getDefaultTokBytes(),
                      base.getDefaultVerifiers(),
                      tWindow,
                      sWindow);
  }

  /** Destruct. The WASM memory will be freed and the object can no longer be
   *  used. */
  destruct = (): void => {
    this.destructBase();
    this.wasm.free(this.decoder); this.decoder.invalidate();
    this.wasm.free(this.saved); this.saved.invalidate();
    this.wasm.free(this.saved64); this.saved64.invalidate();
  }

  /** Instantiate the decoder with the personalization string. The entropy and
   *  nonce callbacks will be called to get the rest of the seeding material.
   *  Returns the status. */
  instantiate = (ps: string): MteStatus => {
    // Create the personalization string in WASM.
    const psWasm = this.wasm.strToWasm(ps);

    // Instantiate.
    const ret = this.exports.mte_wasm_dec_instantiate(this.decoder.off,
                                                      this.instance,
                                                      this.instance,
                                                      psWasm.off, psWasm.used);

    // Free the personalization string.
    this.wasm.free(psWasm);

    // Return the status.
    return ret;
  }

  /** Returns the reseed counter. */
  getReseedCounter = (): number => {
    return this.exports.mte_wasm_dec_reseed_counter(this.decoder.off);
  }

  /** Returns the saved state as a byte array. On error, null is returned. */
  saveState = (): Uint8Array | null => {
    // Save to the save memory. Return the buffer.
    const status = this.exports.mte_dec_state_save(this.decoder.off,
                                                   this.saved.off);
    return status == MteStatus.mte_status_success ?
      new Uint8Array(this.saved.buff!) : null;
  }

  /** Returns the saved state, Base64 encoded. On error, null is returned. */
   saveStateB64 = (): string | null => {
    // Save to the save memory. Return the Base64-encoded string.
    const status = this.exports.mte_wasm_dec_state_save_b64(this.decoder.off,
                                                            this.saved64.off);
    return status == MteStatus.mte_status_success ?
      this.wasm.wasmToStr(this.saved64) : null;
  }

  /** Restore a saved state, which must be the same length as was returned
   *  from the saveState() call. Returns the status. */
  restoreState = (saved: Uint8Array): MteStatus => {
    // Copy to the saved state buffer.
    this.wasm.arrToOffLen(saved, this.saved.off, saved.length);

    // Restore.
    return this.exports.mte_dec_state_restore(this.decoder.off, this.saved.off);
  }

  /** Restore a saved state, which must be the same length as was returned
   *  from the saveStateB64() call. Returns the status. */
   restoreStateB64 = (saved: string): MteStatus => {
    // Copy to the WASM memory.
    const stateWasm = this.wasm.strToWasm(saved);

    // Restore.
    const status = this.exports.mte_wasm_dec_state_restore_b64(this.decoder.off,
                                                               stateWasm.off);

    // Free the WASM memory.
    this.wasm.free(stateWasm);

    // Return status.
    return status;
  }

  /** Decode the given encoded data. Returns the decoded data and status. */
  decode = (encoded: Uint8Array): MteArrStatus => {
    // Copy the message to the WASM memory.
    const wencoded = this.wasm.arrToWasm(encoded);

    // Allocate the decoder buffers.
    const bytes = this.exports.mte_dec_buff_bytes(this.decoder.off,
                                                  encoded.length);
    const decBuff = this.wasm.malloc(bytes);
    const dOff = this.wasm.newInt();
    const dBytes = this.wasm.newInt();
    const et = this.wasm.newInt64();
    const dt = this.wasm.newInt64();
    const ms = this.wasm.newInt();

    // Decode.
    const ret = this.exports.mte_wasm_dec_decode(this.decoder.off,
                                                 this.instance,
                                                 wencoded.off, encoded.length,
                                                 decBuff.off,
                                                 dOff.off,
                                                 dBytes.off,
                                                 et.off,
                                                 dt.off,
                                                 ms.off);
    if (this.statusIsError(ret)) {
      this.wasm.free(wencoded);
      this.wasm.free(decBuff);
      this.wasm.free(dOff);
      this.wasm.free(dBytes);
      this.wasm.free(et);
      this.wasm.free(dt);
      this.wasm.free(ms);
      return { arr: null, status: ret };
    }

    // Copy the decoded data to an array.
    const decOff = this.wasm.wasmToInt(dOff.off);
    const decBytes = this.wasm.wasmToInt(dBytes.off);
    const decoded = decBuff.buff!.slice(decOff, decOff + decBytes);

    // Get the decode values.
    this.encTs = this.wasm.wasmToTimestamp(et);
    this.decTs = this.wasm.wasmToTimestamp(dt);
    this.msgSkipped = this.wasm.wasmToInt(ms.off);

    // Free the buffers.
    this.wasm.free(wencoded);
    this.wasm.free(decBuff);
    this.wasm.free(dOff);
    this.wasm.free(dBytes);
    this.wasm.free(et);
    this.wasm.free(dt);
    this.wasm.free(ms);

    // Return the decoded data and status.
    return { arr: decoded, status: ret };
  }

  /** Decode the given Base64-encoded encoded data. Returns the decoded data
   *  and status. */
  decodeB64 = (encoded: string): MteArrStatus => {
    // Copy the Base64 to the WASM memory.
    const wencoded = this.wasm.strToWasm(encoded);

    // Allocate the decoder buffers.
    const bytes = this.exports.mte_wasm_dec_buff_bytes_b64(this.decoder.off,
                                                           wencoded.used);
    const decBuff = this.wasm.malloc(bytes);
    const dOff = this.wasm.newInt();
    const dBytes = this.wasm.newInt();
    const et = this.wasm.newInt64();
    const dt = this.wasm.newInt64();
    const ms = this.wasm.newInt();

    // Decode.
    const ret = this.exports.mte_wasm_dec_decode_b64(this.decoder.off,
                                                     this.instance,
                                                     wencoded.off,
                                                     wencoded.used,
                                                     decBuff.off,
                                                     dOff.off,
                                                     dBytes.off,
                                                     et.off,
                                                     dt.off,
                                                     ms.off);
    if (this.statusIsError(ret)) {
      this.wasm.free(wencoded);
      this.wasm.free(decBuff);
      this.wasm.free(dOff);
      this.wasm.free(dBytes);
      this.wasm.free(et);
      this.wasm.free(dt);
      this.wasm.free(ms);
      return { arr: null, status: ret };
    }

    // Copy the decoded data to an array.
    const decOff = this.wasm.wasmToInt(dOff.off);
    const decBytes = this.wasm.wasmToInt(dBytes.off);
    const decoded = decBuff.buff!.slice(decOff, decOff + decBytes);

    // Get the decode values.
    this.encTs = this.wasm.wasmToTimestamp(et);
    this.decTs = this.wasm.wasmToTimestamp(dt);
    this.msgSkipped = this.wasm.wasmToInt(ms.off);

    // Free the buffers.
    this.wasm.free(wencoded);
    this.wasm.free(decBuff);
    this.wasm.free(dOff);
    this.wasm.free(dBytes);
    this.wasm.free(et);
    this.wasm.free(dt);
    this.wasm.free(ms);

    // Return the decoded data and status.
    return { arr: decoded, status: ret };
  }

  /** Decode the given encoded version to a string. Returns the string and
   *  status. */
  decodeStr = (encoded: Uint8Array): MteStrStatus => {
    // Copy the encoded to the WASM memory.
    const wencoded = this.wasm.arrToWasm(encoded);

    // Allocate the decoder buffers.
    const bytes = this.exports.mte_dec_buff_bytes(this.decoder.off,
                                                  encoded.length);
    const decBuff = this.wasm.malloc(bytes);
    const dOff = this.wasm.newInt();
    const dBytes = this.wasm.newInt();
    const et = this.wasm.newInt64();
    const dt = this.wasm.newInt64();
    const ms = this.wasm.newInt();

    // Decode.
    const ret = this.exports.mte_wasm_dec_decode(this.decoder.off,
                                                 this.instance,
                                                 wencoded.off, encoded.length,
                                                 decBuff.off,
                                                 dOff.off,
                                                 dBytes.off,
                                                 et.off,
                                                 dt.off,
                                                 ms.off);
    if (this.statusIsError(ret)) {
      this.wasm.free(wencoded);
      this.wasm.free(decBuff);
      this.wasm.free(dOff);
      this.wasm.free(dBytes);
      this.wasm.free(et);
      this.wasm.free(dt);
      this.wasm.free(ms);
      return { str: null, status: ret };
    }

    // Get the decoded data as a string.
    const decOff = this.wasm.wasmToInt(dOff.off);
    const decoded = this.wasm.wasmToStr(decBuff, decOff);

    // Get the decode values.
    this.encTs = this.wasm.wasmToTimestamp(et);
    this.decTs = this.wasm.wasmToTimestamp(dt);
    this.msgSkipped = this.wasm.wasmToInt(ms.off);

    // Free the buffers.
    this.wasm.free(wencoded);
    this.wasm.free(decBuff);
    this.wasm.free(dOff);
    this.wasm.free(dBytes);
    this.wasm.free(et);
    this.wasm.free(dt);
    this.wasm.free(ms);

    // Return the decoded data and status.
    return { str: decoded, status: ret };
  }

  /** Decode the given Base64-encoded encoded version to a string. Returns the
   *  string and status. */
   decodeStrB64 = (encoded: string): MteStrStatus => {
    // Copy the Base64 to the WASM memory.
    const wencoded = this.wasm.strToWasm(encoded);

    // Allocate the decoder buffers.
    const bytes = this.exports.mte_wasm_dec_buff_bytes_b64(this.decoder.off,
                                                           wencoded.used);
    const decBuff = this.wasm.malloc(bytes);
    const dOff = this.wasm.newInt();
    const dBytes = this.wasm.newInt();
    const et = this.wasm.newInt64();
    const dt = this.wasm.newInt64();
    const ms = this.wasm.newInt();

    // Decode.
    const ret = this.exports.mte_wasm_dec_decode_b64(this.decoder.off,
                                                     this.instance,
                                                     wencoded.off,
                                                     wencoded.used,
                                                     decBuff.off,
                                                     dOff.off,
                                                     dBytes.off,
                                                     et.off,
                                                     dt.off,
                                                     ms.off);
    if (this.statusIsError(ret)) {
      this.wasm.free(wencoded);
      this.wasm.free(decBuff);
      this.wasm.free(dOff);
      this.wasm.free(dBytes);
      this.wasm.free(et);
      this.wasm.free(dt);
      this.wasm.free(ms);
      return { str: null, status: ret };
    }

    // Get the decoded data as a string.
    const decOff = this.wasm.wasmToInt(dOff.off);
    const decoded = this.wasm.wasmToStr(decBuff, decOff);

    // Get the decode values.
    this.encTs = this.wasm.wasmToTimestamp(et);
    this.decTs = this.wasm.wasmToTimestamp(dt);
    this.msgSkipped = this.wasm.wasmToInt(ms.off);

    // Free the buffers.
    this.wasm.free(wencoded);
    this.wasm.free(decBuff);
    this.wasm.free(dOff);
    this.wasm.free(dBytes);
    this.wasm.free(et);
    this.wasm.free(dt);
    this.wasm.free(ms);

    // Return the decoded data and status.
    return { str: decoded, status: ret };
  }

  /** Returns the timestamp set during encoding or 0 if there is no
   *  timestamp. */
  getEncTs = (): MteTimestamp => {
    return this.encTs;
  }

  /** Returns the timestamp set during decoding or 0 if there is no
   *  timestamp. */
  getDecTs = (): MteTimestamp => {
    return this.decTs;
  }

  /** Return the number of messages that were skipped to get in sync for the
   *  last decoded message or 0 if there is no sequencing. */
  getMsgSkipped = (): number => {
    return this.msgSkipped;
  }

  /** Uninstantiate. */
  uninstantiate = (): MteStatus => {
    return this.exports.mte_dec_uninstantiate(this.decoder.off);
  }
}


/** This is the MTE Managed-Key Encryption encoder.
 *
 *  To use, create an instance passing the WASM helper which has been
 *  instantiated. */
export class MteMkeEnc extends MteBase {
  /** The encoder. */
  protected encoder: MteMem;

  /** Saved state buffers. */
  private saved: MteMem;
  private saved64: MteMem;

  /** Chunk-based encryption buffer. */
  private chunk: MteMem;

  /** Constructor taking the DRBG, token size in bytes, verifiers algorithm,
   *  cipher algorithm, and hash algorithm. */
  constructor(wasm: MteWasm,
              drbg: MteDrbgs | string,
              tokBytes: number,
              verifiers: MteVerifiers | string,
              cipher: MteCiphers | string,
              hash: MteHashes | string) {
    // Super.
    super(wasm);

    // Get the DRBG, verifier, cipher, and hash as enums if they are strings.
    const drbgE = typeof drbg === "string" ?
      this.getDrbgsAlgo(drbg) : drbg;
    const verifiersE = typeof verifiers === "string" ?
      this.getVerifiersAlgo(verifiers) : verifiers;
    const cipherE = typeof cipher === "string" ?
      this.getCiphersAlgo(cipher) : cipher;
    const hashE = typeof hash === "string" ?
      this.getHashesAlgo(hash) : hash;

    // Initialize the base.
    this.initBase(drbgE, tokBytes, verifiersE, cipherE, hashE);

    // Get the encoder size.
    const bytes = this.exports.mte_wasm_mke_enc_state_bytes(drbgE,
                                                            tokBytes,
                                                            verifiersE,
                                                            cipherE,
                                                            hashE);
    if (bytes == 0) {
      throw new RangeError("MteMkeEnc: Invalid options.");
    }

    // Allocate the encoder.
    this.encoder = wasm.malloc(bytes);

    // Initialize the encoder state.
    const stat = this.exports.mte_wasm_mke_enc_state_init(this.encoder.off,
                                                          drbgE,
                                                          tokBytes,
                                                          verifiersE,
                                                          cipherE,
                                                          hashE);
    if (stat != MteStatus.mte_status_success) {
      throw new RangeError("MteMkeEnc: Invalid options.");
    }

    // Saved state.
    this.saved =
      wasm.malloc(this.exports.mte_mke_enc_save_bytes(this.encoder.off));
    this.saved64 = wasm.malloc(
      this.exports.mte_wasm_mke_enc_save_bytes_b64(this.encoder.off));

    // Chunk-based encryption state.
    this.chunk = wasm.malloc(
      this.exports.mte_mke_enc_encrypt_state_bytes(this.encoder.off));
  }

  /** Create an encoder using default options. */
  public static fromdefault(wasm: MteWasm): MteMkeEnc {
    const base = new MteBase(wasm);
    return new MteMkeEnc(wasm,
                         base.getDefaultDrbg(),
                         base.getDefaultTokBytes(),
                         base.getDefaultVerifiers(),
                         base.getDefaultCipher(),
                         base.getDefaultHash());
  }

  /** Destruct. The WASM memory will be freed and the object can no longer be
   *  used. */
  destruct = (): void => {
    this.destructBase();
    this.wasm.free(this.encoder); this.encoder.invalidate();
    this.wasm.free(this.saved); this.saved.invalidate();
    this.wasm.free(this.saved64); this.saved64.invalidate();
    this.wasm.free(this.chunk); this.chunk.invalidate();
  }

  /** Instantiate the encoder with the personalization string. The entropy and
   *   nonce callbacks will be called to get the rest of the seeding material.
   *   Returns the status. */
  instantiate = (ps: string): MteStatus => {
    // Create the personalization string in WASM.
    const psWasm = this.wasm.strToWasm(ps);

    // Instantiate.
    const ret =
      this.exports.mte_wasm_mke_enc_instantiate(this.encoder.off,
                                                this.instance,
                                                this.instance,
                                                psWasm.off, psWasm.used);

    // Free the personalization string.
    this.wasm.free(psWasm);

    // Return the status.
    return ret;
  }

  /** Returns the reseed counter. */
  getReseedCounter = (): number => {
    return this.exports.mte_wasm_mke_enc_reseed_counter(this.encoder.off);
  }

  /** Returns the saved state as a byte array. On error, null is returned. */
  saveState = (): Uint8Array | null => {
    // Save to the save memory. Return the buffer.
    const status =
      this.exports.mte_mke_enc_state_save(this.encoder.off, this.saved.off);
    return status == MteStatus.mte_status_success ?
      new Uint8Array(this.saved.buff!) : null;
  }

  /** Returns the saved state, Base64 encoded. On error, null is returned. */
   saveStateB64 = (): string | null => {
    // Save to the save memory. Return the Base64-encoded string.
    const status =
      this.exports.mte_wasm_mke_enc_state_save_b64(this.encoder.off,
                                                   this.saved64.off);
    return status == MteStatus.mte_status_success ?
      this.wasm.wasmToStr(this.saved64) : null;
  }

  /** Restore a saved state, which must be the same length as was returned
   *  from the saveState() call. Returns the status. */
  restoreState = (saved: Uint8Array): MteStatus => {
    // Copy to the saved state buffer.
    this.wasm.arrToOffLen(saved, this.saved.off, saved.length);

    // Restore.
    return this.exports.mte_mke_enc_state_restore(this.encoder.off,
                                                  this.saved.off);
  }

  /** Restore a saved state, which must be the same length as was returned
   *  from the saveStateB64() call. Returns the status. */
   restoreStateB64 = (saved: string): MteStatus => {
    // Copy to the WASM memory.
    const stateWasm = this.wasm.strToWasm(saved);

    // Restore.
    const status =
      this.exports.mte_wasm_mke_enc_state_restore_b64(this.encoder.off,
                                                      stateWasm.off);

    // Free the WASM memory.
    this.wasm.free(stateWasm);

    // Return status.
    return status;
  }

  /** Encode the given data. Returns the encoded version and status. */
  encode = (data: Uint8Array): MteArrStatus => {
    // Copy the data to the WASM memory.
    const wdata = this.wasm.arrToWasm(data);

    // Allocate the encoder buffers.
    const bytes = this.exports.mte_mke_enc_buff_bytes(this.encoder.off,
                                                      data.length);
    const encBuff = this.wasm.malloc(bytes);
    const eOff = this.wasm.newInt();
    const eBytes = this.wasm.newInt();

    // Encode.
    const ret = this.exports.mte_wasm_mke_enc_encode(this.encoder.off,
                                                     this.instance,
                                                     wdata.off, data.length,
                                                     encBuff.off,
                                                     eOff.off,
                                                     eBytes.off);
    if (ret != MteStatus.mte_status_success) {
      this.wasm.free(wdata);
      this.wasm.free(encBuff);
      this.wasm.free(eOff);
      this.wasm.free(eBytes);
      return { arr: null, status: ret };
    }

    // Copy the encoded data to an array.
    const encOff = this.wasm.wasmToInt(eOff.off);
    const encBytes = this.wasm.wasmToInt(eBytes.off);
    const encoded = encBuff.buff!.slice(encOff, encOff + encBytes);

    // Free the buffers.
    this.wasm.free(wdata);
    this.wasm.free(encBuff);
    this.wasm.free(eOff);
    this.wasm.free(eBytes);

    // Return the encoded version and status.
    return { arr: encoded, status: ret };
  }

  /** Encode the given data, Base64 encoded. Returns the encoded version and
   *  status. */
  encodeB64 = (data: Uint8Array): MteStrStatus => {
    // Copy the data to the WASM memory.
    const wdata = this.wasm.arrToWasm(data);

    // Allocate the encoder buffers.
    const bytes = this.exports.mte_wasm_mke_enc_buff_bytes_b64(this.encoder.off,
                                                               data.length);
    const encBuff = this.wasm.malloc(bytes);
    const eOff = this.wasm.newInt();
    const eBytes = this.wasm.newInt();

    // Encode.
    const ret = this.exports.mte_wasm_mke_enc_encode_b64(this.encoder.off,
                                                         this.instance,
                                                         wdata.off,
                                                         data.length,
                                                         encBuff.off,
                                                         eOff.off,
                                                         eBytes.off);
    if (ret != MteStatus.mte_status_success) {
      this.wasm.free(wdata);
      this.wasm.free(encBuff);
      this.wasm.free(eOff);
      this.wasm.free(eBytes);
      return { str: null, status: ret };
    }

    // Convert to string.
    const encOff = this.wasm.wasmToInt(eOff.off);
    const encoded = this.wasm.wasmToStr(encBuff, encOff);

    // Free the buffers.
    this.wasm.free(wdata);
    this.wasm.free(encBuff);
    this.wasm.free(eOff);
    this.wasm.free(eBytes);

    // Return the encoded version and status.
    return { str: encoded, status: ret };
  }

  /** Encode the given string. Returns the encoded version and status. */
  encodeStr = (str: string): MteArrStatus => {
    // Convert the string to the WASM memory.
    const wdata = this.wasm.strToWasm(str);

    // Allocate the encoder buffers.
    const bytes = this.exports.mte_mke_enc_buff_bytes(this.encoder.off,
                                                      wdata.used);
    const encBuff = this.wasm.malloc(bytes);
    const eOff = this.wasm.newInt();
    const eBytes = this.wasm.newInt();

    // Encode.
    const ret = this.exports.mte_wasm_mke_enc_encode(this.encoder.off,
                                                     this.instance,
                                                     wdata.off, wdata.used,
                                                     encBuff.off,
                                                     eOff.off,
                                                     eBytes.off);
    if (ret != MteStatus.mte_status_success) {
      this.wasm.free(wdata);
      this.wasm.free(encBuff);
      this.wasm.free(eOff);
      this.wasm.free(eBytes);
      return { arr: null, status: ret };
    }

    // Copy the encoded data to an array.
    const encOff = this.wasm.wasmToInt(eOff.off);
    const encBytes = this.wasm.wasmToInt(eBytes.off);
    const encoded = encBuff.buff!.slice(encOff, encOff + encBytes);

    // Free the buffers.
    this.wasm.free(wdata);
    this.wasm.free(encBuff);
    this.wasm.free(eOff);
    this.wasm.free(eBytes);

    // Return the encoded version and status.
    return { arr: encoded, status: ret };
  }

  /** Encode the given string, Base64 encoded. Returns the encoded version and
   *  status. */
  encodeStrB64 = (str: string): MteStrStatus => {
    // Convert the string to the WASM memory.
    const wdata = this.wasm.strToWasm(str);

    // Allocate the encoder buffers.
    const bytes = this.exports.mte_wasm_mke_enc_buff_bytes_b64(this.encoder.off,
                                                               wdata.used);
    const encBuff = this.wasm.malloc(bytes);
    const eOff = this.wasm.newInt();
    const eBytes = this.wasm.newInt();

    // Encode.
    const ret = this.exports.mte_wasm_mke_enc_encode_b64(this.encoder.off,
                                                         this.instance,
                                                         wdata.off,
                                                         wdata.used,
                                                         encBuff.off,
                                                         eOff.off,
                                                         eBytes.off);
    if (ret != MteStatus.mte_status_success) {
      this.wasm.free(wdata);
      this.wasm.free(encBuff);
      this.wasm.free(eOff);
      this.wasm.free(eBytes);
      return { str: null, status: ret };
    }

    // Convert to string.
    const encOff = this.wasm.wasmToInt(eOff.off);
    const encoded = this.wasm.wasmToStr(encBuff, encOff);

    // Free the buffers.
    this.wasm.free(wdata);
    this.wasm.free(encBuff);
    this.wasm.free(eOff);
    this.wasm.free(eBytes);

    // Return the encoded version and status.
    return { str: encoded, status: ret };
  }

  /** Returns the length of the result finishEncrypt() will produce. Use this
      if you need to know that size before you can call it. */
  encryptFinishBytes = (): number => {
    return this.exports.mte_mke_enc_encrypt_finish_bytes(this.encoder.off);
  }

  /** Start a chunk-based encryption session. Returns the status. */
  startEncrypt = (): MteStatus => {
    return this.exports.mte_mke_enc_encrypt_start(this.encoder.off,
                                                  this.chunk.off);
  }

  /** Encrypt a chunk of data in a chunk-based encryption session. Returns the
   *  encrypted data. The length must be a multiple of the chosen cipher's
   *  block size. Returns null on error. */
  encryptChunk = (data: Uint8Array): Uint8Array | null => {
    // Copy to WASM memory.
    const wdata = this.wasm.arrToWasm(data);

    // Encrypt.
    const stat = this.exports.mte_wasm_mke_enc_encrypt_chunk(this.encoder.off,
                                                             this.chunk.off,
                                                             wdata.off,
                                                             data.length,
                                                             wdata.off);

    // Copy to the return buffer.
    let encrypted: Uint8Array | null = null;
    if (stat == MteStatus.mte_status_success) {
      encrypted = new Uint8Array(wdata.buff!);
    }

    // Free the WASM memory.
    this.wasm.free(wdata);

    // Return the encrypted data.
    return encrypted;
  }

  /** Finish a chunk-based encryption session. Returns the final part of the
   *  result and status. */
  finishEncrypt = (): MteArrStatus => {
    // Allocate the result offset and size.
    const rOff = this.wasm.newInt();
    const rBytes = this.wasm.newInt();

    // Finish the session.
    const ret = this.exports.mte_wasm_mke_enc_encrypt_finish(this.encoder.off,
                                                             this.chunk.off,
                                                             this.instance,
                                                             rOff.off,
                                                             rBytes.off);
    if (ret != MteStatus.mte_status_success) {
      this.wasm.free(rOff);
      this.wasm.free(rBytes);
      return { arr: null, status: ret };
    }

    // Copy the final result to a buffer.
    const resOff = this.wasm.wasmToInt(rOff.off);
    const resBytes = this.wasm.wasmToInt(rBytes.off);
    const result = this.chunk.buff!.slice(resOff, resOff + resBytes);

    // Free the result offset and size.
    this.wasm.free(rOff);
    this.wasm.free(rBytes);

    // Return the result and status.
    return { arr: result, status: ret };
  }

  /** Uninstantiate. */
  uninstantiate = (): MteStatus => {
    return this.exports.mte_mke_enc_uninstantiate(this.encoder.off);
  }
}

/** This is the MTE Managed-Key Encryption decoder.
 *
 *  To use, create an instance passing the WASM helper which has been
 *  instantiated. */
export class MteMkeDec extends MteBase {
  /** The decoder. */
  protected decoder: MteMem;

  /** Saved state buffers. */
  private saved: MteMem;
  private saved64: MteMem;

  /** Chunk-based decryptor state. */
  private chunk: MteMem;
  private ciphBlockBytes: number;

  /** Decode values. */
  private encTs: MteTimestamp = { ts: 0, upper: 0 };
  private decTs: MteTimestamp = { ts: 0, upper: 0 };
  private msgSkipped: number = 0;

  /** Constructor taking the DRBG, token size in bytes, verifiers algorithm,
   *  cipher algorith, hash algorithm, timestamp window, and sequence window. */
  constructor(wasm: MteWasm,
              drbg: MteDrbgs | string,
              tokBytes: number,
              verifiers: MteVerifiers | string,
              cipher: MteCiphers | string,
              hash: MteHashes | string,
              tWindow: number,
              sWindow: number) {
    // Super.
    super(wasm);

    // Get the DRBG, verifier, cipher, and hash as enums if they are strings.
    const drbgE = typeof drbg === "string" ?
      this.getDrbgsAlgo(drbg) : drbg;
    const verifiersE = typeof verifiers === "string" ?
      this.getVerifiersAlgo(verifiers) : verifiers;
    const cipherE = typeof cipher === "string" ?
      this.getCiphersAlgo(cipher) : cipher;
    const hashE = typeof hash === "string" ?
      this.getHashesAlgo(hash) : hash;

    // Initialize the base.
    this.initBase(drbgE, tokBytes, verifiersE, cipherE, hashE);

    // Get the decoder size.
    const bytes = this.exports.mte_wasm_mke_dec_state_bytes(drbgE,
                                                            tokBytes,
                                                            verifiersE,
                                                            cipherE,
                                                            hashE);
    if (bytes == 0) {
      throw new RangeError("MteMkeDec: Invalid options.");
    }

    // Allocate the decoder/decryptor.
    this.decoder = wasm.malloc(bytes);

    // Initialize the decoder/decryptor state.
    const stat = this.exports.mte_wasm_mke_dec_state_init(this.decoder.off,
                                                          drbgE,
                                                          tokBytes,
                                                          verifiersE,
                                                          cipherE,
                                                          hashE,
                                                          tWindow,
                                                          sWindow);
    if (stat != MteStatus.mte_status_success) {
      throw new RangeError("MteMkeDec: Invalid options.");
    }

    // Saved state.
    this.saved =
      wasm.malloc(this.exports.mte_mke_dec_save_bytes(this.decoder.off));
    this.saved64 = wasm.malloc(
      this.exports.mte_wasm_mke_dec_save_bytes_b64(this.decoder.off));

    // Chunk-based decryptor state.
    this.chunk = wasm.malloc(
      this.exports.mte_mke_dec_decrypt_state_bytes(this.decoder.off));
    this.ciphBlockBytes = this.getCiphersBlockBytes(cipherE);
    if (this.ciphBlockBytes == 0) {
      throw new RangeError("MteMkeDec: Invalid options.");
    }
  }

  /** Create a decoder using default options.
   *
   *  The timestamp window and sequence window are optionally settable. */
  public static fromdefault(wasm: MteWasm, tWindow = 0, sWindow = 0):MteMkeDec {
    const base = new MteBase(wasm);
    return new MteMkeDec(wasm,
                         base.getDefaultDrbg(),
                         base.getDefaultTokBytes(),
                         base.getDefaultVerifiers(),
                         base.getDefaultCipher(),
                         base.getDefaultHash(),
                         tWindow,
                         sWindow);
  }

  /** Destruct. The WASM memory will be freed and the object can no longer be
   *  used. */
  destruct = (): void => {
    this.destructBase();
    this.wasm.free(this.decoder); this.decoder.invalidate();
    this.wasm.free(this.saved); this.saved.invalidate();
    this.wasm.free(this.saved64); this.saved64.invalidate();
    this.wasm.free(this.chunk); this.chunk.invalidate();
  }

  /** Instantiate the decoder/decryptor with the personalization string. The
   *  entropy and nonce callbacks will be called to get the rest of the seeding
   *  material. Returns the status. */
  instantiate = (ps: string): MteStatus => {
    // Create the personalization string in WASM.
    const psWasm = this.wasm.strToWasm(ps);

    // Instantiate.
    const ret =
      this.exports.mte_wasm_mke_dec_instantiate(this.decoder.off,
                                                this.instance,
                                                this.instance,
                                                psWasm.off, psWasm.used);

    // Free the personalization string.
    this.wasm.free(psWasm);

    // Return the status.
    return ret;
  }

  /** Returns the reseed counter. */
  getReseedCounter = (): number => {
    return this.exports.mte_wasm_mke_dec_reseed_counter(this.decoder.off);
  }

  /** Returns the saved state as a byte array. On error, null is returned. */
  saveState = (): Uint8Array | null => {
    // Save to the save memory. Return the buffer.
    const status =
      this.exports.mte_mke_dec_state_save(this.decoder.off, this.saved.off);
    return status == MteStatus.mte_status_success ?
      new Uint8Array(this.saved.buff!) : null;
  }

  /** Returns the saved state, Base64 encoded. On error, null is returned. */
   saveStateB64 = (): string | null => {
    // Save to the save memory. Return the Base64-encoded string.
    const status =
      this.exports.mte_wasm_mke_dec_state_save_b64(this.decoder.off,
                                                   this.saved64.off);
    return status == MteStatus.mte_status_success ?
      this.wasm.wasmToStr(this.saved64) : null;
  }

  /** Restore a saved state, which must be the same length as was returned
   *  from the saveState() call. Returns the status. */
  restoreState = (saved: Uint8Array): MteStatus => {
    // Copy to the saved state buffer.
    this.wasm.arrToOffLen(saved, this.saved.off, saved.length);

    // Restore.
    return this.exports.mte_mke_dec_state_restore(this.decoder.off,
                                                  this.saved.off);
  }

  /** Restore a saved state, which must be the same length as was returned
   *  from the saveStateB64() call. Returns the status. */
   restoreStateB64 = (saved: string): MteStatus => {
    // Copy to the WASM memory.
    const stateWasm = this.wasm.strToWasm(saved);

    // Restore.
    const status =
      this.exports.mte_wasm_mke_dec_state_restore_b64(this.decoder.off,
                                                      stateWasm.off);

    // Free the WASM memory.
    this.wasm.free(stateWasm);

    // Return status.
    return status;
  }

  /** Decode the given encoded data. Returns the decoded data and status. */
  decode = (encoded: Uint8Array): MteArrStatus => {
    // Copy the message to the WASM memory.
    const wencoded = this.wasm.arrToWasm(encoded);

    // Allocate the decoder buffers.
    const bytes = this.exports.mte_mke_dec_buff_bytes(this.decoder.off,
                                                      encoded.length);
    if (bytes == 0) {
      this.wasm.free(wencoded);
      return { arr: null, status: MteStatus.mte_status_invalid_input };
    }
    const decBuff = this.wasm.malloc(bytes);
    const dOff = this.wasm.newInt();
    const dBytes = this.wasm.newInt();
    const et = this.wasm.newInt64();
    const dt = this.wasm.newInt64();
    const ms = this.wasm.newInt();

    // Decode.
    const ret =
      this.exports.mte_wasm_mke_dec_decode(this.decoder.off,
                                           this.instance,
                                           wencoded.off, encoded.length,
                                           decBuff.off,
                                           dOff.off,
                                           dBytes.off,
                                           et.off,
                                           dt.off,
                                           ms.off);
    if (this.statusIsError(ret)) {
      this.wasm.free(wencoded);
      this.wasm.free(decBuff);
      this.wasm.free(dOff);
      this.wasm.free(dBytes);
      this.wasm.free(et);
      this.wasm.free(dt);
      this.wasm.free(ms);
      return { arr: null, status: ret };
    }

    // Copy the decoded data to an array.
    const decOff = this.wasm.wasmToInt(dOff.off);
    const decBytes = this.wasm.wasmToInt(dBytes.off);
    const decoded = decBuff.buff!.slice(decOff, decOff + decBytes);

    // Get the decode values.
    this.encTs = this.wasm.wasmToTimestamp(et);
    this.decTs = this.wasm.wasmToTimestamp(dt);
    this.msgSkipped = this.wasm.wasmToInt(ms.off);

    // Free the buffers.
    this.wasm.free(wencoded);
    this.wasm.free(decBuff);
    this.wasm.free(dOff);
    this.wasm.free(dBytes);
    this.wasm.free(et);
    this.wasm.free(dt);
    this.wasm.free(ms);

    // Return the decoded data and status.
    return { arr: decoded, status: ret };
  }

  /** Decode the given Base64-encoded encoded data. Returns the decoded data
   *  and status. */
   decodeB64 = (encoded: string): MteArrStatus => {
    // Copy the Base64 to the WASM memory.
    const wencoded = this.wasm.strToWasm(encoded);

    // Allocate the decoder buffers.
    const bytes = this.exports.mte_wasm_mke_dec_buff_bytes_b64(this.decoder.off,
                                                               wencoded.used);
    const decBuff = this.wasm.malloc(bytes);
    const dOff = this.wasm.newInt();
    const dBytes = this.wasm.newInt();
    const et = this.wasm.newInt64();
    const dt = this.wasm.newInt64();
    const ms = this.wasm.newInt();

    // Decode.
    const ret = this.exports.mte_wasm_mke_dec_decode_b64(this.decoder.off,
                                                         this.instance,
                                                         wencoded.off,
                                                         wencoded.used,
                                                         decBuff.off,
                                                         dOff.off,
                                                         dBytes.off,
                                                         et.off,
                                                         dt.off,
                                                         ms.off);
    if (this.statusIsError(ret)) {
      this.wasm.free(wencoded);
      this.wasm.free(decBuff);
      this.wasm.free(dOff);
      this.wasm.free(dBytes);
      this.wasm.free(et);
      this.wasm.free(dt);
      this.wasm.free(ms);
      return { arr: null, status: ret };
    }

    // Copy the decoded data to an array.
    const decOff = this.wasm.wasmToInt(dOff.off);
    const decBytes = this.wasm.wasmToInt(dBytes.off);
    const decoded = decBuff.buff!.slice(decOff, decOff + decBytes);

    // Get the decode values.
    this.encTs = this.wasm.wasmToTimestamp(et);
    this.decTs = this.wasm.wasmToTimestamp(dt);
    this.msgSkipped = this.wasm.wasmToInt(ms.off);

    // Free the buffers.
    this.wasm.free(wencoded);
    this.wasm.free(decBuff);
    this.wasm.free(dOff);
    this.wasm.free(dBytes);
    this.wasm.free(et);
    this.wasm.free(dt);
    this.wasm.free(ms);

    // Return the decoded data and status.
    return { arr: decoded, status: ret };
  }

  /** Decode the given encoded version to a string. Returns the string and
   *  status. */
  decodeStr = (encoded: Uint8Array): MteStrStatus => {
    // Copy the encoded to the WASM memory.
    const wencoded = this.wasm.arrToWasm(encoded);

    // Allocate the decoder buffers.
    const bytes = this.exports.mte_mke_dec_buff_bytes(this.decoder.off,
                                                      encoded.length);
    if (bytes == 0) {
      this.wasm.free(wencoded);
      return { str: null, status: MteStatus.mte_status_invalid_input };
    }
    const decBuff = this.wasm.malloc(bytes);
    const dOff = this.wasm.newInt();
    const dBytes = this.wasm.newInt();
    const et = this.wasm.newInt64();
    const dt = this.wasm.newInt64();
    const ms = this.wasm.newInt();

    // Decode.
    const ret = this.exports.mte_wasm_mke_dec_decode(this.decoder.off,
                                                     this.instance,
                                                     wencoded.off,
                                                     encoded.length,
                                                     decBuff.off,
                                                     dOff.off,
                                                     dBytes.off,
                                                     et.off,
                                                     dt.off,
                                                     ms.off);
    if (this.statusIsError(ret)) {
      this.wasm.free(wencoded);
      this.wasm.free(decBuff);
      this.wasm.free(dOff);
      this.wasm.free(dBytes);
      this.wasm.free(et);
      this.wasm.free(dt);
      this.wasm.free(ms);
      return { str: null, status: ret };
    }

    // Get the decoded data as a string.
    const decOff = this.wasm.wasmToInt(dOff.off);
    const decoded = this.wasm.wasmToStr(decBuff, decOff);

    // Get the decode values.
    this.encTs = this.wasm.wasmToTimestamp(et);
    this.decTs = this.wasm.wasmToTimestamp(dt);
    this.msgSkipped = this.wasm.wasmToInt(ms.off);

    // Free the buffers.
    this.wasm.free(wencoded);
    this.wasm.free(decBuff);
    this.wasm.free(dOff);
    this.wasm.free(dBytes);
    this.wasm.free(et);
    this.wasm.free(dt);
    this.wasm.free(ms);

    // Return the decoded data and status.
    return { str: decoded, status: ret };
  }

  /** Decode the given Base64-encoded encoded version to a string. Returns the
   *  string and status. */
   decodeStrB64 = (encoded: string): MteStrStatus => {
    // Copy the Base64 to the WASM memory.
    const wencoded = this.wasm.strToWasm(encoded);

    // Allocate the decoder buffers.
    const bytes = this.exports.mte_wasm_mke_dec_buff_bytes_b64(this.decoder.off,
                                                               wencoded.used);
    const decBuff = this.wasm.malloc(bytes);
    const dOff = this.wasm.newInt();
    const dBytes = this.wasm.newInt();
    const et = this.wasm.newInt64();
    const dt = this.wasm.newInt64();
    const ms = this.wasm.newInt();

    // Decode.
    const ret = this.exports.mte_wasm_mke_dec_decode_b64(this.decoder.off,
                                                         this.instance,
                                                         wencoded.off,
                                                         wencoded.used,
                                                         decBuff.off,
                                                         dOff.off,
                                                         dBytes.off,
                                                         et.off,
                                                         dt.off,
                                                         ms.off);
    if (this.statusIsError(ret)) {
      this.wasm.free(wencoded);
      this.wasm.free(decBuff);
      this.wasm.free(dOff);
      this.wasm.free(dBytes);
      this.wasm.free(et);
      this.wasm.free(dt);
      this.wasm.free(ms);
      return { str: null, status: ret };
    }

    // Get the decoded data as a string.
    const decOff = this.wasm.wasmToInt(dOff.off);
    const decoded = this.wasm.wasmToStr(decBuff, decOff);

    // Get the decode values.
    this.encTs = this.wasm.wasmToTimestamp(et);
    this.decTs = this.wasm.wasmToTimestamp(dt);
    this.msgSkipped = this.wasm.wasmToInt(ms.off);

    // Free the buffers.
    this.wasm.free(wencoded);
    this.wasm.free(decBuff);
    this.wasm.free(dOff);
    this.wasm.free(dBytes);
    this.wasm.free(et);
    this.wasm.free(dt);
    this.wasm.free(ms);

    // Return the decoded data and status.
    return { str: decoded, status: ret };
  }

  /** Start a chunk-based decryption session. Returns the status. */
  startDecrypt = (): MteStatus => {
    return this.exports.mte_mke_dec_decrypt_start(this.decoder.off,
                                                  this.chunk.off);
  }

  /** Decrypt a chunk of data in a chunk-based decryption session. Returns the
   *  decrypted data. Returns null on error. */
  decryptChunk = (encrypted: Uint8Array): Uint8Array | null => {
    // Copy to WASM memory.
    const wencr = this.wasm.arrToWasm(encrypted);

    // Allocate space for the decrypted.
    const dBytes = this.wasm.newInt();
    const buffBytes = encrypted.length + this.ciphBlockBytes;
    const wdecr = this.wasm.malloc(buffBytes);

    // Decrypt.
    const status = this.exports.mte_wasm_mke_dec_decrypt_chunk(this.decoder.off,
                                                               this.chunk.off,
                                                               wencr.off,
                                                               encrypted.length,
                                                               wdecr.off,
                                                               dBytes.off);

    // Copy to the return buffer.
    const decBytes = this.wasm.wasmToInt(dBytes.off);
    const decrypted = wdecr.buff!.slice(0, decBytes);

    // Free WASM memory.
    this.wasm.free(wencr);
    this.wasm.free(wdecr);
    this.wasm.free(dBytes);

    // Return the decrypted data.
    return status == MteStatus.mte_status_success ? decrypted : null;
  }

  /** Finish a chunk-based decryption session. Returns the final part of the
   *  result and status. */
  finishDecrypt = (): MteArrStatus => {
    // Finish the session.
    const dOff = this.wasm.newInt();
    const dBytes = this.wasm.newInt();
    const et = this.wasm.newInt64();
    const dt = this.wasm.newInt64();
    const ms = this.wasm.newInt();
    const ret = this.exports.mte_wasm_mke_dec_decrypt_finish(this.decoder.off,
                                                             this.chunk.off,
                                                             this.instance,
                                                             dOff.off,
                                                             dBytes.off,
                                                             et.off,
                                                             dt.off,
                                                             ms.off);
    if (this.statusIsError(ret)) {
      this.wasm.free(dOff);
      this.wasm.free(dBytes);
      this.wasm.free(et);
      this.wasm.free(dt);
      this.wasm.free(ms);
      return { arr: null, status: ret };
    }

    // Copy the final decrypted data to a buffer.
    const decOff = this.wasm.wasmToInt(dOff.off);
    const decBytes = this.wasm.wasmToInt(dBytes.off);
    const decrypted = this.chunk.buff!.slice(decOff, decOff + decBytes);

    // Get the decode values.
    this.encTs = this.wasm.wasmToTimestamp(et);
    this.decTs = this.wasm.wasmToTimestamp(dt);
    this.msgSkipped = this.wasm.wasmToInt(ms.off);

    // Free the buffers.
    this.wasm.free(dOff);
    this.wasm.free(dBytes);
    this.wasm.free(et);
    this.wasm.free(dt);
    this.wasm.free(ms);

    // Return the decrypted data and status.
    return { arr: decrypted, status: ret };
  }

  /** Returns the timestamp set during encoding or 0 if there is no
   *  timestamp. */
  getEncTs = (): MteTimestamp => {
    return this.encTs;
  }

  /** Returns the timestamp set during decoding or 0 if there is no
   *  timestamp. */
  getDecTs = (): MteTimestamp => {
    return this.decTs;
  }

  /** Return the number of messages that were skipped to get in sync for the
   *  last decoded message or 0 if there is no sequencing. */
  getMsgSkipped = (): number => {
    return this.msgSkipped;
  }

  /** Uninstantiate. */
  uninstantiate = (): MteStatus => {
    return this.exports.mte_mke_dec_uninstantiate(this.decoder.off);
  }
}

/** This is the abstract MTE Secure Data Replacement Add-On.
 *
 *  To use, create an instance of a derived SDR. The derived SDR must override
 *  some of and may override all of the methods starting with "impl". The "impl"
 *  functions should be used directly; use only the read*() and write*()
 *  functions.
 *
 *  The term "directory" is an abstraction meant to imply a grouping of files.
 *  The specific implementation may use the directory in any way.
 */
export class MteSdrAbs {
  /** The WASM helper. */
  protected wasm: MteWasm;

  /** The encoder and decoder. */
  private enc: MteMkeEnc;
  private dec: MteMkeDec;
  private entropy = new Uint8Array(0);
  private nonce: Uint8Array;

  /** The SDR path. */
  private sdrPath: string;

  /** Memory files. */
  private memFiles = new Map<string, Uint8Array>();

  /** Constructor taking the MKE encoder/decoder and directory for the SDR to
   *  use.
   *
   *  Note: the MKE encoder/decoder provided to this object cannot be used
   *  outside this object as this object will change their states.
   */
  constructor(enc: MteMkeEnc, dec: MteMkeDec, sdrDir: string) {
    // Save the encoder and decoder.
    this.enc = enc;
    this.dec = dec;
    this.wasm = enc.wasm;

    // Set the callbacks to null to ensure our entropy and nonce will be used
    // and to ensure timestamps are disabled.
    this.enc.setEntropyCallback(null);
    this.dec.setEntropyCallback(null);
    this.enc.setNonceCallback(null);
    this.dec.setNonceCallback(null);
    this.enc.setTimestampCallback(null);
    this.dec.setTimestampCallback(null);

    // Set the correct nonce size based on the DRBG.
    const nonceMin = enc.getDrbgsNonceMinBytes(enc.getDrbg());
    const nonceMax = enc.getDrbgsNonceMaxBytes(enc.getDrbg());
    const nonceBytes = Math.min(Math.max(nonceMin, 8), nonceMax);
    this.nonce = new Uint8Array(nonceBytes);

    // Save the SDR path.
    this.sdrPath = sdrDir;
  }

  /** Returns the MKE encoder in use. This should only be used for
   *  information.
   */
  getEncoder = (): MteMkeEnc => {
    return this.enc;
  }

  /** Returns the MKE decoder in use. This should only be used for
   *  information.
   */
  getDecoder = (): MteMkeDec => {
    return this.dec;
  }

  /** Initializes the SDR with the entropy and nonce to use. Throws an
   *  exception if the SDR cannot be created.
   */
  initSdr = (entropy: Uint8Array, nonce: string): void => {
    // Save the entropy and nonce.
    this.entropy = entropy;
    this.nonce.fill(0);
    for (let i = 0; i < nonce.length; ++i) {
      let carry = parseInt(nonce.charAt(i));
      for (let j = 0; j < this.nonce.length; ++j) {
        let digit = (this.nonce[j] * 10) + carry;
        this.nonce[j] = digit % 256;
        carry = Math.floor(digit / 256);
      }
    }

    // If the SDR directory does not exist, create it.
    if (!this.implDirExists(this.sdrPath)) {
      this.implCreateDir(this.sdrPath);
    }
  }

  /** Read from storage or memory as data. If the same name exists in memory
   *  and on storage, the memory version is read. Throws an exception on I/O
   *  error or MTE error.
   */
  readData = (name: string): Uint8Array => {
    let encodedAll: Uint8Array;

    // Read the data.
    if (this.memFiles.has(name)) {
      encodedAll = this.memFiles.get(name)!;
    } else {
      encodedAll = this.implReadFile(this.sdrPath, name);
    }

    // Extract the timestamp. XOR the nonce into it.
    const nonce = new Uint8Array(this.nonce.length);
    for (let i = 0; i < nonce.length; ++i) {
      nonce[i] = encodedAll[i] ^ this.nonce[i];
    }

    // Copy the entropy because it will be zeroized. Instantiate with this name
    // and the SDR entropy and nonce.
    const eCopy = Uint8Array.from(this.entropy);
    this.dec.setEntropyArr(eCopy);
    this.dec.setNonceArr(nonce);
    const status = this.dec.instantiate(name);
    if (status != MteStatus.mte_status_success) {
      throw new Error("Error instantiating decoder (" +
                      this.dec.getStatusName(status) +
                      "): " +
                      this.dec.getStatusDescription(status));
    }

    // Remove the timestamp that is prepended.
    const encoded = encodedAll.slice(nonce.length);

    // Decode the data.
    const as = this.dec.decode(encoded);
    if (as.status != MteStatus.mte_status_success) {
      throw new Error("Error decoding data (" +
                      this.dec.getStatusName(as.status) +
                      "): " +
                      this.dec.getStatusDescription(as.status));
    }

    // Return the data.
    return as.arr!;
  }

  /** Read from storage or memory as a string. If the same name exists in memory
   *  and on storage, the memory version is read. Throws an exception on I/O
   *  error or MTE error.
   */
  readString = (name: string): string => {
    let encodedAll: Uint8Array;

    // Read the data.
    if (this.memFiles.has(name)) {
      encodedAll = this.memFiles.get(name)!;
    } else {
      encodedAll = this.implReadFile(this.sdrPath, name);
    }

    // Extract the timestamp. XOR the nonce into it.
    const nonce = new Uint8Array(this.nonce.length);
    for (let i = 0; i < nonce.length; ++i) {
      nonce[i] = encodedAll[i] ^ this.nonce[i];
    }

    // Copy the entropy because it will be zeroized. Instantiate with this name
    // and the SDR entropy and nonce.
    const eCopy = Uint8Array.from(this.entropy);
    this.dec.setEntropyArr(eCopy);
    this.dec.setNonceArr(nonce);
    const status = this.dec.instantiate(name);
    if (status != MteStatus.mte_status_success) {
      throw new Error("Error instantiating decoder (" +
                      this.dec.getStatusName(status) +
                      "): " +
                      this.dec.getStatusDescription(status));
    }

    // Remove the timestamp that is prepended.
    const encoded = encodedAll.slice(nonce.length);

    // Decode the data.
    const ss = this.dec.decodeStr(encoded);
    if (ss.status != MteStatus.mte_status_success) {
      throw new Error("Error decoding data (" +
                      this.dec.getStatusName(ss.status) +
                      "): " +
                      this.dec.getStatusDescription(ss.status));
    }

    // Return the data.
    return ss.str!;
  }

  /** Write the given data to storage or memory. If the name matches the name
   *  of a previously written file, this will overwrite it. If toMemory is
   *  true, the data or string is saved to memory and not written to
   *  permanent storage; there are no restrictions on the contents of the
   *  name argument. If toMemory is false, the data or string is saved to
   *  permanent storage in the SDR directory set in the constructor; the name
   *  argument must be a valid name for the type of storage. Throws an exception
   *  on I/O error or MTE error.
   */
  writeData = (name: string,
               data: Uint8Array,
               toMemory: boolean = false): void => {
    // Get the timestamp. XOR the nonce into it.
    const ts = this.implGetTimestamp();
    const nonce = new Uint8Array(this.nonce.length);
    for (let i = 0; i < nonce.length; ++i) {
      nonce[i] = ts[i] ^ this.nonce[i];
    }

    // Copy the entropy because it will be zeroized. Instantiate with this name
    // and the SDR entropy and nonce.
    const eCopy = Uint8Array.from(this.entropy);
    this.enc.setEntropyArr(eCopy);
    this.enc.setNonceArr(nonce);
    const status = this.enc.instantiate(name);
    if (status != MteStatus.mte_status_success) {
      throw new Error("Error instantiating encoder (" +
                      this.enc.getStatusName(status) +
                      "): " +
                      this.enc.getStatusDescription(status));
    }

    // Encode the data.
    const as = this.enc.encode(data);
    if (as.status != MteStatus.mte_status_success) {
      throw new Error("Error encoding data (" +
                      this.enc.getStatusName(as.status) +
                      "): " +
                      this.enc.getStatusDescription(as.status));
    }

    // Prepend the timestamp to the encoded version.
    const encoded = new Uint8Array(as.arr!.length + ts.length);
    for (let i = 0; i < ts.length; ++i) {
      encoded[i] = ts[i];
    }
    for (let i = 0; i < as.arr!.length; ++i) {
      encoded[i + ts.length] = as.arr![i];
    }

    // If saving to memory, add it to the memory map.
    if (toMemory) {
      this.memFiles.set(name, encoded);
    } else {
      this.implWriteFile(this.sdrPath, name, encoded);
    }
  }

  /** Write the given string to storage or memory. If the name matches the name
   *  of a previously written file, this will overwrite it. If toMemory is
   *  true, the data or string is saved to memory and not written to
   *  permanent storage; there are no restrictions on the contents of the
   *  name argument. If toMemory is false, the data or string is saved to
   *  permanent storage in the SDR directory set in the constructor; the name
   *  argument must be a valid name for the type of storage. Throws an exception
   *  on I/O error or MTE error.
   */
  writeString = (name: string,
                 str: string,
                 toMemory: boolean = false): void => {
    // Get the timestamp. XOR the nonce into it.
    const ts = this.implGetTimestamp();
    const nonce = new Uint8Array(this.nonce.length);
    for (let i = 0; i < nonce.length; ++i) {
      nonce[i] = ts[i] ^ this.nonce[i];
    }

    // Copy the entropy because it will be zeroized. Instantiate with this name
    // and the SDR entropy and nonce.
    const eCopy = Uint8Array.from(this.entropy);
    this.enc.setEntropyArr(eCopy);
    this.enc.setNonceArr(nonce);
    const status = this.enc.instantiate(name);
    if (status != MteStatus.mte_status_success) {
      throw new Error("Error instantiating encoder (" +
                      this.enc.getStatusName(status) +
                      "): " +
                      this.enc.getStatusDescription(status));
    }

    // Encode the data.
    const as = this.enc.encodeStr(str);
    if (as.status != MteStatus.mte_status_success) {
      throw new Error("Error encoding data (" +
                      this.enc.getStatusName(as.status) +
                      "): " +
                      this.enc.getStatusDescription(as.status));
    }

    // Prepend the timestamp to the encoded version.
    const encoded = new Uint8Array(as.arr!.length + ts.length);
    for (let i = 0; i < ts.length; ++i) {
      encoded[i] = ts[i];
    }
    for (let i = 0; i < as.arr!.length; ++i) {
      encoded[i + ts.length] = as.arr![i];
    }

    // If saving to memory, add it to the memory map.
    if (toMemory) {
      this.memFiles.set(name, encoded);
    } else {
      this.implWriteFile(this.sdrPath, name, encoded);
    }
  }

  /** Removes an SDR item. If the same name exists in memory and on storage,
   *  the memory version is removed.
   *
   *  It is not an error to remove an item that does not exist. An exception is
   *  thrown if the file exists and cannot be removed.
   */
  remove = (name: string): void => {
    // Remove from memory if it exists there.
    if (this.memFiles.has(name)) {
      this.memFiles.delete(name);
    } else {
      // Remove from the SDR if it exists there.
      this.implRemoveFile(this.sdrPath, name);
    }
  }

  /** Removes the SDR. All memory and storage items are removed. This object
   *  is not usable until a new call to initSdr().
   *
   *  It is not an error to remove a SDR that does not exist. An exception is
   *  thrown if any file in the SDR cannot be removed.
   */
  removeSdr = (): void => {
    // If the SDR directory exists, remove.
    if (this.implDirExists(this.sdrPath)) {
      // Remove each file.
      const files = this.implListFiles(this.sdrPath);
      for (let i = 0; i < files.length; ++i) {
        this.implRemoveFile(this.sdrPath, files[i]);
      }

      // Remove the SDR directory.
      this.implRemoveDir(this.sdrPath);
    }
  }

  /** Returns true if the directory exists, false if not. This implementation
   *  returns true.
   */
  implDirExists = (dir: string): boolean => {
    dir;
    return true;
  }

  /** Returns a list of file basenames in a directory. Throws an exception on
   *  failure. This implementation returns an empty list.
   */
  implListFiles = (dir: string): Array<string> => {
    dir;
    return [];
  }

  /** Creates a directory, including any intermediate directories as necessary.
   *  Throws an exception on failure. This implementation does nothing.
   */
  implCreateDir = (dir: string): void => {
    dir;
  }

  /** Reads a file. Returns the file contents. Throws an exception on failure.
   *  This implementation throws an exception.
   */
  implReadFile = (dir: string, file: string): Uint8Array => {
    dir;
    file;
    throw new Error("MteSdrAbs.readFile() called.");
  }

  /** Writes a file. Throws an exception on failure. This implementation throws
   *  an exception.
   */
  implWriteFile = (dir: string, file: string, contents: Uint8Array): void => {
    dir;
    file;
    contents;
    throw new Error("MteSdrAbs.writeFile() called.");
  }

  /** Removes a directory. Throws an exception on failure. This implementation
   *  does nothing.
   */
  implRemoveDir = (dir: string): void => {
    dir;
  }

  /** Removes a file. Throws an exception on failure. This implementation does
   *  nothing.
   */
  implRemoveFile = (dir: string, file: string): void => {
    dir;
    file;
  }

  /** Returns the timestamp in big endian to increase entropy since the nonce
   *  is little endian.
   */
  implGetTimestamp = (): Uint8Array => {
    // Get the current timestamp.
    let tsInt = Math.floor(Date.now());

    // Place it in the array in big-endian order.
    const ts = new Uint8Array(this.nonce.length);
    for (let i = ts.length - 1; i >= 0; --i) {
      ts[i] = tsInt % 256;
      tsInt = Math.floor(tsInt / 256);
    }

    // Return the timestamp.
    return ts;
  }
}

/** This is the MTE Secure Data Replacement Add-On which stores files as
 *  cookies.
 *
 *  Use the MteSdrAbs interface, not the "impl" functions found here.
 *
 *  The "directory" is used as a prefix to the filenames to distinguish them
 *  from other cookies and from other cookie SDRs.
 */
export class MteSdrCookie extends MteSdrAbs {
  /** Cookie attributes suffix. */
  private attrs: string;

  /** Constructor taking the MKE encoder/decoder, directory for the SDR to
   *  use, and cookie attributes to append.
   *
   *  Note that a cookie attribute starts with a semicolon to separate it from
   *  the previous value or attribute. Therefore, to add a max age of 100, the
   *  attrs should be "; max-age=100".
   *
   *  Note: the MKE encoder/decoder provided to this object cannot be used
   *  outside this object as this object will change their states.
   */
  constructor(enc: MteMkeEnc, dec: MteMkeDec, sdrDir: string, attrs: string) {
    // Super.
    super(enc, dec, sdrDir);

    // Save the attributes.
    this.attrs = attrs;
  }

  /** Create an SDR at the given directory with the cookie attributes to
   *  append. Default-constructed MKE encoder and decoder are created.
   */
  public static fromdefault(wasm: MteWasm,
                            sdrDir: string,
                            attrs: string): MteSdrCookie {
    return new MteSdrCookie(MteMkeEnc.fromdefault(wasm),
                            MteMkeDec.fromdefault(wasm),
                            sdrDir,
                            attrs);
  }

  /** Returns a list of file basenames in a directory. Throws an exception on
   *  failure.
   */
  implListFiles = (dir: string): Array<string> => {
    // Create the cookie name prefix.
    const name = dir + "_";

    // Filter the cookie list by the prefix, keeping the cookie name, removing
    // the prefix.
    return document.cookie.split(';').filter((item) =>
      item.trim().startsWith(name)).map((item) =>
      item.split('=')[0].trim().slice(name.length));
  }

  /** Reads a file. Returns the file contents. Throws an exception on failure.
   */
  implReadFile = (dir: string, file: string): Uint8Array => {
    // Find the file.
    const name = dir + "_" + file + "=";
    const cookie = document.cookie.split(';').filter((item) =>
      item.trim().startsWith(name));
    if (cookie.length != 1) {
      throw new Error("Could not find cookie.");
    }

    // Decode the cookie value, then Base64 decode that to get the data.
    const c = cookie[0];
    return this.wasm.b64decode(decodeURIComponent(c.split("=")[1].trim()));
  }

  /** Writes a file. Throws an exception on failure. */
  implWriteFile = (dir: string, file: string, contents: Uint8Array): void => {
    // Base64 encode the data. Encode that with the URI component rules to
    // ensure a valid cookie value.
    const encoded = encodeURIComponent(this.wasm.b64encode(contents));

    // Set the cookie, appending the attributes.
    document.cookie = dir + "_" + file + "=" + encoded + this.attrs;
  }

  /** Removes a file. Throws an exception on failure. */
  implRemoveFile = (dir: string, file: string): void => {
    // Set the cookie with an expiration of zero.
    document.cookie = dir + "_" + file + "=_; max-age=0";
  }
}

/** This is the MTE Secure Data Replacement Add-On which stores files in local
 *  or session storage.
 *
 *  Use the MteSdrAbs interface, not the "impl" functions found here.
 *
 *  The "directory" is used as a prefix to the filenames to distinguish them
 *  from other storage files and from other storage file SDRs.
 */
export class MteSdrStorage extends MteSdrAbs {
  /** Storage. */
  private storage: Storage;

  /** Constructor taking the MKE encoder/decoder, directory for the SDR to
   *  use, and storage to use (true = local, false = session).
   *
   *  Note: the MKE encoder/decoder provided to this object cannot be used
   *  outside this object as this object will change their states.
   */
  constructor(enc: MteMkeEnc, dec: MteMkeDec, sdrDir: string,
              useLocal: boolean) {
    // Super.
    super(enc, dec, sdrDir);

    // Get the correct storage.
    this.storage = useLocal ? window.localStorage : window.sessionStorage;
  }

  /** Create an SDR at the given directory with the storage choice. Default-
   *  constructed MKE encoder and decoder are created.
   */
  public static fromdefault(wasm: MteWasm,
                            sdrDir: string,
                            useLocal: boolean): MteSdrStorage {
    return new MteSdrStorage(MteMkeEnc.fromdefault(wasm),
                             MteMkeDec.fromdefault(wasm),
                             sdrDir,
                             useLocal);
  }

  /** Returns a list of file basenames in a directory. Throws an exception on
   *  failure.
   */
  implListFiles = (dir: string): Array<string> => {
    // Create the name prefix.
    const name = dir + "/";

    // Iterate the keys of the storage looking for matches.
    const files = new Array<string>();
    for (let i = 0; i < this.storage.length; ++i) {
      const key = this.storage.key(i);
      if (key!.startsWith(name)) {
        files.push(key!.slice(name.length));
      }
    }

    return files;
  }

  /** Reads a file. Returns the file contents. Throws an exception on failure.
   */
  implReadFile = (dir: string, file: string): Uint8Array => {
    // Find the file.
    const name = dir + "/" + file;
    const item = this.storage.getItem(name);
    if (item == null) {
      throw new Error("Could not find file.");
    }

    // Base64 decode the item value to get the data.
    return this.wasm.b64decode(item);
  }

  /** Writes a file. Throws an exception on failure. */
  implWriteFile = (dir: string, file: string, contents: Uint8Array): void => {
    // Base64 encode the data.
    const encoded = this.wasm.b64encode(contents);

    // Set the value.
    const name = dir + "/" + file;
    this.storage.setItem(name, encoded);
  }

  /** Removes a file. Throws an exception on failure. */
  implRemoveFile = (dir: string, file: string): void => {
    const name = dir + "/" + file;
    this.storage.removeItem(name);
  }
}






/** Class MteRandom
 *
 * This is a class for the random generator function.
 *
 * This class requires the availability of Web Cryptography API (crypto module).
 * https://www.w3.org/TR/WebCryptoAPI/
 *
 */
export class MteRandom {

  static getBytes = (buffer: Uint8Array): boolean => {
    if (buffer.length == 0)
      return false;
    if (typeof window === "undefined") {
      // In server-side context or nodejs
      // @ts-ignore
      const crypto = require("crypto");
      crypto.getRandomValues(buffer);
      return true;
    } else {
      // In browser context
      window.crypto.getRandomValues(buffer);
      return true;
    }
  }

}





/** This is the MTE Diffie-Hellman key exchange add-on.
 *
 *  To use, create an instance passing the WASM helper which has been
 *  instantiated and the desired security strength. */

export enum MteKyberStrength {
    none = 0,
    K512 = 512,
    K768 = 768,
    K1024 = 1024
  }

export enum MteKyberStatus {
  success = 0,
  invalidStrength = -1,
  entropyFail = -2,
  invalidPubKey = -3,
  invalidPrivKey = -4,
  memoryFail = -5,
  invalidCipherText = -6
}

/** An array and status. */
export interface MteKyberResults {
  /** The 1st result. */
  result1: Uint8Array | null;
  /** The 2nd result, if applicable. */
  result2: Uint8Array | null;
  /** The status. */
  status: MteKyberStatus;
}

export class MteKyber {

  /** The WASM helper. */
  readonly wasm: MteWasm;
  readonly exports: MteWasmExports;
  readonly memory: WebAssembly.Memory;

  /** Instances. */
  private static readonly instances: (MteKyber | null)[] = [];
  /** Instance index. */
  private instance: number;

  /** Sizes. */
  private publicKeySize:number = 0;
  private privateKeySize:number = 0;
  private minEntropySize:number = 0;
  private maxEntropySize:number = 0;
  private encryptedSize:number = 0;
  private secretSize:number = 0; 

  /** The current strength. */
  private static strength: MteKyberStrength = MteKyberStrength.none;

  /** The private key. */
  private privateKey: Uint8Array | null = null;

  /* Implementation. */
  private myEntropyCb: MteKyberCallback | null = null;
  private myEntropy: Uint8Array | null = null;

  /** Constructor which needs no parameters. */
  constructor(wasm: MteWasm, strength: MteKyberStrength) {

    // Check for the current strength setting.
    if (MteKyber.strength !== MteKyberStrength.none &&
        MteKyber.strength !== strength) {
      throw new TypeError
                ("MteKyber: differing Kyber strengths are not supported.");
    }

    // Reference the WASM.
    this.wasm = wasm;
    if (wasm.exports !== null) {
      this.exports = wasm.exports;
    } else {
      throw new TypeError("MteKyber: WASM does not have exports.");
    }
    if (wasm.memory !== null) {
      this.memory = wasm.memory;
    } else {
      throw new TypeError("MteKyber: WASM does not have memory.");
    }

    // Set the WASM callbacks.
    if (wasm.kyberCallback === null) {
      wasm.kyberCallback = this.defaultCallback;
    }

    // Register the instance.
    this.instance = -1;
    for (let i = 0; i < MteKyber.instances!.length; i++) {
      if (MteKyber.instances![i] === null) {
        this.instance = i;
        break;
      }
    }
    if (this.instance === -1) {    
      this.instance = MteKyber.instances!.length;
      MteKyber.instances!.push(this);
    } else {
      MteKyber.instances![this.instance] = this;
    }

    // Setup Kyber.
    if (this.exports.mte_wasm_kyber_init(strength) != MteKyberStatus.success) {
      throw new TypeError("MteKyber: intializing the strength failed.");
    } else {
      MteKyber.strength = strength;
      this.publicKeySize = this.exports.mte_wasm_kyber_get_pubkey_size();
      this.privateKeySize = this.exports.mte_wasm_kyber_get_privkey_size();
      this.minEntropySize = this.exports.mte_wasm_kyber_get_min_entropy_size();
      this.maxEntropySize = this.exports.mte_wasm_kyber_get_max_entropy_size();
      this.encryptedSize = this.exports.mte_wasm_kyber_get_encrypted_size();
      this.secretSize = this.exports.mte_wasm_kyber_get_secret_size();
    }
  }

  /** These functions provide information on sizes for keys and
   *  encrypted and unencrypted secrets as well as entropy requirements
   *  and a human readable representation of the current algorithm. */
  getPublicKeySize = (): number => {
    return this.publicKeySize;
  }

  getSecretSize = (): number => {
    return this.secretSize;
  }

  getEncryptedSize = (): number => {
    return this.encryptedSize;
  }

  getminEntropySize = (): number => {
    return this.minEntropySize;
  }

  getMaxEntropySize = (): number => {
    return this.maxEntropySize;
  }

  getAlgorithm = (): string => {
    const off = this.exports.mte_wasm_kyber_get_algorithm();
    return this.wasm.wasmOffToStr(off);
  }

  /** Set the entropy callback. If not null, it is called to get entropy. If
   *  null, the entropy set with setEntropy() is used. If that was not set
   *  either, the internal random number generator is used. */
  setEntropyCallback = (cb: MteKyberCallback | null): void => {
    this.myEntropyCb = cb;
  }

  /** Set the entropy input value. This must be done before calling
   *  createKeypair which will trigger the entropy callback.
   *
   *  The entropy is zeroized immediately.
   *
   *  If the entropy callback is null, entropyInput is used as the entropy. */
  setEntropy = (entropy: Uint8Array): MteKyberStatus => {
    if (entropy.length < this.minEntropySize ||
        entropy.length > this.maxEntropySize)
      return MteKyberStatus.entropyFail;
    // Copy entropy to myEntropy and zeroize entropy
    this.myEntropy = new Uint8Array(entropy.length);
    for (let i = 0; i < entropy.length; ++i) {
      this.myEntropy[i] = entropy[i];
      entropy[i] = 0;
    }
    return MteKyberStatus.success;
  }

  /** Creates a key pair and returns the public key along
   *  with the status. The private key is kept within the class. */
  createKeypair = (): MteKyberResults => {
    let status: MteKyberStatus = MteKyberStatus.success;
    // Create the buffers for public and private keys.
    const wPublic = this.wasm.malloc(this.publicKeySize);
    const wPublicBytes = this.wasm.newInt();
    this.wasm.intToWasm(wPublicBytes.off, this.publicKeySize);
    const wPrivate = this.wasm.malloc(this.privateKeySize);
    const wPrivateBytes = this.wasm.newInt();
    this.wasm.intToWasm(wPrivateBytes.off, this.privateKeySize);
    // Create the key pair
    status = this.exports.mte_wasm_kyber_create_keypair
             (wPrivate.off, wPrivateBytes.off,
              wPublic.off, wPublicBytes.off,
              this.instance);
    if (status != MteKyberStatus.success) {
      // Free the wasm resources
      this.wasm.free(wPublic);
      this.wasm.free(wPublicBytes);
      this.wasm.free(wPrivate);
      this.wasm.free(wPrivateBytes);
      return { result1: null, result2: null, status: status };
    }
    // Copy the keys from wasm.
    const publicKey = wPublic.buff!.slice(0, this.publicKeySize);
    this.privateKey = wPrivate.buff!.slice(0, this.privateKeySize);
    // Free the wasm resources
    this.wasm.free(wPublic);
    this.wasm.free(wPublicBytes);
    this.wasm.free(wPrivate);
    this.wasm.free(wPrivateBytes);
    return { result1: publicKey, result2: null, status: status };
  }

  /** Returns the shared secret using the peer public key along
   *  with the status. */
  createSecret = (peerPublicKey: Uint8Array): MteKyberResults => {
    // Copy the data to the WASM memory.
    const wPeerPubKey = this.wasm.arrToWasm(peerPublicKey);
    // Create the buffer to receive the unencrypted secret.
    const wSecret = this.wasm.malloc(this.secretSize);
    // The length for the unencrypted secret.
    const wSecretBytes = this.wasm.newInt();
    this.wasm.intToWasm(wSecretBytes.off, this.secretSize);
    // Create the buffer to receive the encrypted secret.
    const wEncrypted = this.wasm.malloc(this.encryptedSize);
    // The length for the unencrypted secret.
    const wEncryptedBytes = this.wasm.newInt();
    this.wasm.intToWasm(wEncryptedBytes.off, this.encryptedSize);
    // Create the secret.
    const rc = this.exports.mte_wasm_kyber_create_secret
               (wPeerPubKey.off, peerPublicKey.length,
                wSecret.off, wSecretBytes.off,
                wEncrypted.off, wEncryptedBytes.off,
                this.instance);
    // Free the wasm key resources
    this.wasm.free(wPeerPubKey);
    // Bail out if not successful.
    if (rc !== MteKyberStatus.success) {
      // Free the wasm secret resources
      this.wasm.free(wSecret);
      this.wasm.free(wSecretBytes);
      this.wasm.free(wEncrypted);
      this.wasm.free(wEncryptedBytes);
      return { result1: null, result2: null, status: rc };
    }
    // Create the results.
    const secret = wSecret.buff!.slice(0, this.secretSize);
    const encrypted = wEncrypted.buff!.slice(0, this.encryptedSize);
    // Free the wasm secret resources
    this.wasm.free(wSecret);
    this.wasm.free(wSecretBytes);
    this.wasm.free(wEncrypted);
    this.wasm.free(wEncryptedBytes);
    // Return the secret and successful status.
    return { result1: secret, result2: encrypted,
             status: MteKyberStatus.success };
  }

  /** Decrypts the given encrypted secret using the the internally
   *  stored private key. Fails if there is no private key.
   *  Returns the decrypted secret along with the status. */
  decryptSecret = (encrypted: Uint8Array): MteKyberResults => {
    if (this.privateKey === null)
      return { result1: null, result2: null,
               status: MteKyberStatus.invalidPrivKey };
    // Copy the data to the WASM memory.
    const wPrivateKey = this.wasm.arrToWasm(this.privateKey);
    const wEncrypted = this.wasm.arrToWasm(encrypted);
    // Create the buffer to receive the unencrypted secret.
    const wSecret = this.wasm.malloc(this.secretSize);
    // The length for the unencrypted secret.
    const wSecretBytes = this.wasm.newInt();
    this.wasm.intToWasm(wSecretBytes.off, this.secretSize);
    // Decrypt the secret.
    const rc = this.exports.mte_wasm_kyber_decrypt_secret
               (wPrivateKey.off, this.privateKey.length,
                wEncrypted.off, encrypted.length,
                wSecret.off, wSecretBytes.off);
    // Free the wasm key resources
    this.wasm.free(wPrivateKey);
    this.wasm.free(wEncrypted);
    // Bail out if not successful.
    if (rc !== MteKyberStatus.success) {
      // Free the wasm secret resources
      this.wasm.free(wSecret);
      this.wasm.free(wSecretBytes);
      return { result1: null, result2: null, status: rc };
    }
    // Create the results.
    const secret = wSecret.buff!.slice(0, this.secretSize);
    // Free the wasm secret resources
    this.wasm.free(wSecret);
    this.wasm.free(wSecretBytes);
    // Return the secret and successful status.
    return { result1: secret, result2: null,
             status: MteKyberStatus.success };
  }

  /** Zeroize the given byte array. */
  static zeroize = (dest: Uint8Array): void => {
    for (let i = 0; i < dest.length; ++i) {
      dest[i] = 0;
    }
  }

  /** Destruct. Remove our instance from the instances. */
  destruct = (): void => {
    MteKyber.instances[this.instance] = null;
    while (MteKyber.instances!.length > 0 &&
           MteKyber.instances![MteKyber.instances!.length - 1] == null) {
      MteKyber.instances!.pop();
    }
  }

  /** The entropy callback. */
  defaultCallback = (context: number,
                     entropy: number, entropyBytes: number,
                     minEntropyBytes: number,
                     maxEntropyBytes: number): MteKyberStatus => {
    // Get the MTE instance.
    const myInstance = MteKyber.instances![context];

    // Call the override callback if set.
    if (myInstance!.myEntropyCb !== null) {
      return myInstance!.myEntropyCb.entropyCallback
             (entropy, entropyBytes, minEntropyBytes, maxEntropyBytes);
    }

    // Check if we even have myEntropy
    if (myInstance!.myEntropy === null) {
      let randBytes = new Uint8Array(minEntropyBytes);
      if (!MteRandom.getBytes(randBytes))
        return MteKyberStatus.entropyFail;
      // Copy random bytes to wasm and zeroize original
      let dest = this.wasm.wasmOverlay(entropy, minEntropyBytes);
      for (let i = 0; i < minEntropyBytes; ++i) {
        dest[i] = randBytes[i];
        randBytes[i] = 0;
      }
      // Update the entropy size
      myInstance!.wasm.intToWasm(entropyBytes, minEntropyBytes);
    } else {
      // Copy myEntropy bytes to wasm and zeroize original
      let dest = this.wasm.wasmOverlay(entropy, myInstance!.myEntropy.length);
      for (let i = 0; i < myInstance!.myEntropy.length; ++i) {
        dest[i] = myInstance!.myEntropy[i];
        myInstance!.myEntropy[i] = 0;
      }
      // Update the entropy size
      myInstance!.wasm.intToWasm(entropyBytes, myInstance!.myEntropy.length);
      myInstance!.myEntropy = null;
    }
    // Success.
    return MteKyberStatus.success;
  }
}

/** Signature of a Kyber entropy callback. */
export interface MteKyberCallback {
  entropyCallback(
  /** Offset in WASM memory of the 32-bit offset in WASM memory of the provided
   *  array of the length given by maxEntropyBytes. The length is fixed. */
  entropy: number,

  /** Offset in WASM memory of the 32-bit length of the provided array on input;
   *  initially holds the same value as in maxEntropyBytes which equals the size
   *  of the provided buffer. The callback must set the 32-bit length of the
   *  actual entropy here. */
  entropyBytes: number,

  /** Offset in WASM memory of the 32-bit minimum entropy size;
   *  the value is for information only. It cannot be changed. */
  minEntropyBytes: number,

  /** Offset in WASM memory of the 32-bit maximum entropy size;
   *  the value is for information only. It cannot be changed. */
  maxEntropyBytes: number
  ): MteKyberStatus;
}



/** Signature of an entropy input callback. */
export interface MteEntropyCallback {
  entropyCallback(
    /** The minimum entropy. */
    minEntropy: number,

    /** The minimum length in bytes. */
    minLength: number,

    /** The maximum length in bytes. */
    maxLength: number,

    /** Offset in WASM memory of the 32-bit offset in WASM memory of the
     *  provided array of length given by eiBytes. If larger entropy must be
     *  provided, WASM memory must be allocated and the 32-bit offset set to
     *  the offset of it. */
    entropyInput: number,

    /** Offset in WASM memory of the 32-bit length of the provided array on
     *  input; the callback must set the 32-bit length of the actual entropy
     *  here. */
    eiBytes: number
  ): MteStatus;
}

/** Signature of a nonce callback. */
export interface MteNonceCallback {
  nonceCallback(
    /** The minimum nonce length. */
    minLength: number,

    /** The maximum nonce length. */
    maxLength: number,

    /** Offset in WASM memory of the nonce array to write the nonce to. */
    nonce: number,

    /** Offset in WASM memory of the 32-bit nonce length. The callback must set
     *  this to the actual nonce length. */
    nBytes: number
  ): void;
}

/** A timestamp. */
export interface MteTimestamp {
  /** Either the lower 32 bits of the timestamp or the entire timestamp if less
   *  than or equal to Number.MAX_SAFE_INTEGER. */
  ts: number,

  /** The upper 32 bits of the timestamp if not 0. If 0, the ts member contains
   *  the entire value. */
  upper: number
}

/** Signature of a timestamp callback.
 *
 *  Returns the timestamp as a string representing a 64-bit integer in
 *  decimal. */
export interface MteTimestampCallback {
  timestampCallback(): MteTimestamp;
}

/** Helpers to interface to MTE WASM.
 *
 *  To use, create a single instance of this type, then call instantiate() once
 *  on that instance to get the WASM instantiated. Once that has completed
 *  successfully, MTE objects can be created, taking reference to the single
 *  instance of this type. */
export class MteWasm {
  /** Callbacks. */
  kyberCallback: null | MteKyberCallbackWasm = null;
  entropyCallback: null | MteEntropyCallbackWasm = null;
  nonceCallback: null | MteNonceCallbackWasm = null;
  timestampCallback: null | MteTimestampCallbackWasm = null;
  /** WASM exports and memory. */
  exports: null | MteWasmExports = null;
  memory: null | WebAssembly.Memory = null;

  /** WASM page size (64 KB). */
  private readonly pageBytes: number = 64 * 1024;

  /** Heap base offset. */
  private base = 0;

  /** Heap size. */
  private bytes = 0;

  /** Blocks. */
  private blocks: MteHeapBlock[] = [];

  /** Instantiate the WASM. This should be done only once. Returns a promise
   *  that must be fulfilled before the object is usable. */
  instantiate = (): Promise<void> => {
    return new Promise(async(resolve, reject) => {
      try {
        // Set up the imports.
        const funcs = {
          mte_wasm_kyber_cb: this.kyberCallbackWasm,
          mte_wasm_ei_cb: this.entropyCallbackWasm,
          mte_wasm_n_cb: this.nonceCallbackWasm,
          mte_wasm_t_cb: this.timestampCallbackWasm
        };
        const imports = {
          env: funcs,
          imports: funcs
        };

        // Create the WASM array.
        const wasmData = new MteWasmData();

        // Instantiate the WASM using the imports.
        const wmodule = await WebAssembly.compile(wasmData.wasmArr);
        const wasm = await WebAssembly.instantiate(wmodule, imports);
        this.exports = (wasm.exports as unknown) as MteWasmExports;

        // Set the memory.
        this.memory = this.exports.memory;
        this.base = this.memory.buffer.byteLength;

        // Resolve the promise.
        resolve();
      }
      catch(err) {
        // Reject the promise on error.
        reject(err);
      }
    });
  }

  /** Allocate the given amount of memory. Returns an MteMem object that holds
   *  the memory offset in WASM and a JS buffer to access it. */
  malloc = (bytes: number): MteMem => {
    // Get the WASM memory.
    const mem = this.memory!;

    // Look for a block with enough available.
    const count = this.blocks.length;
    for (let i = 0; i < count; ++i) {
      // If the block is not in use and big enough, use it.
      if (!this.blocks[i].inUse && this.blocks[i].bytes >= bytes) {
        // If the block is bigger than needed, split it.
        if (this.blocks[i].bytes > bytes) {
          this.blocks.splice(i + 1,
                             0,
                             new MteHeapBlock(this.blocks[i].off + bytes,
                                              this.blocks[i].bytes - bytes));
          this.blocks[i].bytes = bytes;
        }

        // Return a memory object describing the block.
        const mteMem = new MteMem(this.blocks[i].off,
                                  new Uint8Array(mem.buffer,
                                                 this.blocks[i].off,
                                                 bytes));
        this.blocks[i].inUse = true;
        this.blocks[i].mteMem = mteMem;
        return mteMem;
      }
    }

    // If no blocks had enough available, the WASM memory (and therefore our
    // heap) will have to grow. Figure out how many WASM pages we need and grow.
    const prevBytes = mem.buffer.byteLength;
    const pages = Math.ceil(bytes / this.pageBytes);
    mem.grow(pages);

    // The grow operation detaches the ArrayBuffer so all existing memory
    // object buffers have to be recreated.
    for (let i = 0; i < count; ++i) {
      if (this.blocks[i].inUse) {
        this.blocks[i].mteMem!.buff = new Uint8Array(mem.buffer,
                                                     this.blocks[i].off,
                                                     this.blocks[i].bytes);
      }
    }

    // If the last block is not in use, add to it.
    const newBytes = mem.buffer.byteLength - prevBytes;
    if (this.blocks.length != 0 &&
        !this.blocks[this.blocks.length - 1].inUse) {
      this.blocks[this.blocks.length - 1].bytes += newBytes;
    }
    else {
      // Otherwise add a new block.
      this.blocks.push(new MteHeapBlock(this.base + this.bytes, newBytes));
    }
    this.bytes += newBytes;

    // Now we know we have a big enough free block. Call again to allocate it.
    return this.malloc(bytes);
  }

  /** Free the memory described by the given MteMem object. */
  free = (mem: MteMem): void => {
    // Find the block.
    let i = 0;
    const count = this.blocks.length;
    for (; i < count; ++i) {
      if (this.blocks[i].off == mem.off) {
        break;
      }
    }
    if (i == count) {
      return;
    }

    // If the previous block is not in use, combine this block back in to it.
    if (i != 0 && !this.blocks[i - 1].inUse) {
      this.blocks[i - 1].bytes += this.blocks[i].bytes;
      this.blocks.splice(i, 1);
      --i;
    }
    else {
      // Otherwise mark this block as not in use.
      this.blocks[i].inUse = false;
      this.blocks[i].mteMem = null;
    }

    // If the block following the (possibly combined in to previous) block is
    // not in use, combine that block in to this.
    if (i < this.blocks.length - 1 && !this.blocks[i + 1].inUse) {
      this.blocks[i].bytes += this.blocks[i + 1].bytes;
      this.blocks.splice(i + 1, 1);
    }
  }

  /** Convert the 4 bytes at the given WASM offset to an integer. Returns the
   *  value. */
  wasmToInt = (off: number): number => {
    // Get a byte array at the offset.
    const bytes = this.wasmOverlay(off, 4);

    // Create the integer from the little-endian bytes.
    return  bytes[0]               + // 2^0
           (bytes[1] * 0x00000100) + // 2^8
           (bytes[2] * 0x00010000) + // 2^16
           (bytes[3] * 0x01000000);  // 2^24
  }

  /** Set the 4 bytes at the given WASM offset from the given integer value. */
  intToWasm = (off: number, i: number): void => {
    // Get a byte array at the offset.
    const bytes = this.wasmOverlay(off, 4);

    // Set each byte in little-endian.
    bytes[0] =  i        & 0xff;
    bytes[1] = (i >>  8) & 0xff;
    bytes[2] = (i >> 16) & 0xff;
    bytes[3] =  i >> 24        ;
  }

  /** Allocate memory for an integer. Returns the memory object. */
  newInt = (): MteMem => {
    return this.malloc(4);
  }

  /** Convert the 8 bytes at the given WASM offset to an integer. Returns the
   *  value. */
  wasmToInt64 = (off: number): number => {
    // Get a byte array at the offset.
    const bytes = this.wasmOverlay(off, 8);

    // Create the integer from the little-endian bytes. Only the bottom 53 bits
    // should be used, so the last byte is ignored. If the value is 2^53 or
    // higher, the result will no longer be accurate.
    return  bytes[0]                       + // 2^0
           (bytes[1] * 0x0000000000000100) + // 2^8
           (bytes[2] * 0x0000000000010000) + // 2^16
           (bytes[3] * 0x0000000001000000) + // 2^24
           (bytes[4] * 0x0000000100000000) + // 2^32
           (bytes[5] * 0x0000010000000000) + // 2^40
           (bytes[6] * 0x0001000000000000);  // 2^48
  }

  /** Set the 8 bytes at the given WASM offset from the given integer value. */
  int64ToWasm = (off: number, i: number): void => {
    // Get a byte array at the offset.
    const bytes = this.wasmOverlay(off, 8);

    // Set each byte in little-endian. Only the bottom 53 bits should be used,
    // so the last byte is always zero. If the value is 2^53 or higher, the
    // result will no longer be accurate.
    for (let idx = 0; idx < 6; ++idx) {
      bytes[idx] = i & 0xff; i /= 256;
    }
    bytes[6] = i & 0xff;
    bytes[7] = 0;
  }

  /** Allocate memory for a 64-bit integer. Returns the memory object. */
  newInt64 = (): MteMem => {
    return this.malloc(8);
  }

  /** Convert the 64-bit value to a timestamp object. */
  wasmToTimestamp = (val: MteMem): MteTimestamp => {
    // If the upper 11 bits are zero, this is a safe integer so we can just read
    // it directly.
    if (val.buff![7] == 0 && (val.buff![6] & 0xE0) == 0) {
      return { ts: this.wasmToInt64(val.off), upper: 0 };
    }

    // Otherwise it has to be read as two 32-bit parts.
    return { ts: this.wasmToInt(val.off), upper: this.wasmToInt(val.off + 4) };
  }

  /** Overlay WASM memory at the given offset of the given length. Returns the
   *  array overlay. */
  wasmOverlay = (off: number, bytes: number): Uint8Array => {
    return new Uint8Array(this.memory!.buffer, off, bytes);
  }

  /** Get the array at the given WASM offset of the given length. Returns the
   *  array. */
  wasmToArr = (off: number, bytes: number): Uint8Array => {
    // Overlay.
    const overlay = this.wasmOverlay(off, bytes);

    // Copy.
    const arr = new Uint8Array(bytes);
    for (let i = 0; i < bytes; ++i) {
      arr[i] = overlay[i];
    }

    // Return the copy.
    return arr;
  }

  /** Allocate memory for an array and copy it to WASM memory. Returns the
   *  memory object. */
  arrToWasm = (arr: Uint8Array): MteMem => {
    // Allocate WASM memory.
    const mem = this.malloc(arr.length);

    // Copy.
    for (let i = 0; i < arr.length; ++i) {
      mem.buff![i] = arr[i];
    }

    // Return the memory.
    return mem;
  }

  /** Copy the given array to a WASM offset and length. */
  arrToOffLen = (arr: Uint8Array, off: number, bytes: number): void => {
    // Overlay and copy.
    const overlay = this.wasmOverlay(off, bytes);
    for (let i = 0; i < bytes; ++i) {
      overlay[i] = arr[i];
    }
  }

  /** Copy the given JS string to WASM memory. Returns the memory object. */
  strToWasm = (str: string, extra = 0): MteMem => {
    // Make sure it's a string.
    str = String(str);

    // Allocate the maximum memory this could take for UTF-8 plus a null
    // terminator and plus any extra desired buffer.
    const mem = this.malloc((str.length * 4) + 1 + extra);
    const buff = mem.buff!;

    // Convert the string to UTF-8.
    let index = 0;
    for (let i = 0; i < str.length; ++i) {
      let code = str.charCodeAt(i);
      if (code < 0x80) {
        buff[index] = code;
        ++index;
      } else if (code < 0x0800) {
        buff[index] = 0xc0 | (code >> 6);
        ++index;
        buff[index] = 0x80 | (code & 0x3f);
        ++index;
      } else if (code < 0xd800 || code >= 0xe000) {
        buff[index] = 0xe0 | (code >> 12);
        ++index;
        buff[index] = 0x80 | ((code >> 6) & 0x3f);
        ++index;
        buff[index] = 0x80 | (code & 0x3f);
        ++index;
      } else {
        code = ((code & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff) | 0x010000;
        buff[index] = 0xf0 | (code >> 18);
        ++index;
        buff[index] = 0x80 | ((code >> 12) & 0x3f);
        ++index;
        buff[index] = 0x80 | ((code >> 6) & 0x3f);
        ++index;
        buff[index] = 0x80 | (code & 0x3f);
        ++index;
      }
    }

    // Update the memory object with how much we actually wrote and return it
    // after null terminating.
    mem.used = index;
    buff[index] = 0;
    return mem;
  }

  /** Create a JS string from WASM memory. Returns the string. */
  wasmToStr = (mem: MteMem, start = 0): string => {
    // Step through the JS array overlaying the WASM memory, converting to
    // string from UTF-8. Stop at any null terminator byte even if before the
    // reported used size of the array.
    let code: number;
    let str = "";
    const buff = mem.buff!;
    for (let i = start; i < mem.used; ) {
      if (buff[i] == 0) {
        break;
      }
      else if (buff[i] < 0x80) {
        str += String.fromCharCode(buff[i]);
        ++i;
      }
      else if (buff[i] > 0xbf && buff[i] < 0xe0) {
        code = ((buff[i] & 0x1f) << 6) | (buff[i + 1] & 0x3f);
        str += String.fromCharCode(code);
        i += 2;
      }
      else if (buff[i] > 0xdf && buff[i] < 0xf0) {
        code =
          ((buff[i] & 0x0f) << 12) |
          ((buff[i + 1] & 0x3f) << 6) |
          (buff[i + 2] & 0x3f);
        str += String.fromCharCode(code);
        i += 3;
      }
      else {
        code =
          ((buff[i] & 0x07) << 18) |
          ((buff[i + 1] & 0x3f) << 12) |
          ((buff[i + 2] & 0x3f) << 6) |
          ((buff[i + 3] & 0x3f) - 0x010000);
        str += String.fromCharCode(code);
        i += 4;
      }
    }

    // Return the string.
    return str;
  }

  /** Create a JS string from the given offset in WASM memory. Returns the
   *  string. */
  wasmOffToStr = (off: number, start = 0): string => {
    const cstr = this.wasmOverlay(off, this.memory!.buffer.byteLength - off);
    return this.wasmToStr(new MteMem(-1, cstr), start);
  }

  /** Base64 encode the given array. Returns the Base64. */
  b64encode = (arr: Uint8Array): string => {
    // Copy the array to the WASM memory.
    const wasmArr = this.arrToWasm(arr);

    // Allocate WASM memory for the encode.
    const b64Bytes = this.exports!.mte_wasm_base64_encode_bytes(arr.length);
    const b64Arr = this.malloc(b64Bytes);

    // Base64 encode.
    this.exports!.mte_wasm_base64_encode(wasmArr.off, arr.length, b64Arr.off);

    // Convert to a string.
    const b64 = this.wasmToStr(b64Arr);

    // Free WASM buffers.
    this.free(wasmArr);
    this.free(b64Arr);

    // Return the Base64 string.
    return b64;
  }

  /** Base64 decode the given string. Returns the array. */
  b64decode = (b64: string): Uint8Array => {
    // Copy the string to WASM memory.
    const wasmB64 = this.strToWasm(b64);

    // Base64 decode.
    const bytes = this.exports!.mte_wasm_base64_decode(wasmB64.off);

    // Convert to an array.
    const arr = this.wasmToArr(wasmB64.off, bytes);

    // Free WASM buffers.
    this.free(wasmB64);

    // Return the array.
    return arr;
  }


  /** The Kyber callback for WASM. Calls the registered callback. */
  kyberCallbackWasm = (context: number,
                       entropy: number,
                       entropyBytes: number,
                       minEntropyBytes: number,
                       maxEntropyBytes: number): number => {
    if (this.kyberCallback === null) {
      throw new TypeError("Missing Kyber callback.");
    }
    return this.kyberCallback(context, entropy, entropyBytes,
                              minEntropyBytes, maxEntropyBytes);
  }

  /** The entropy callback for WASM. Calls the registered callback. */
  entropyCallbackWasm = (context: number,
                         minEntropy: number,
                         minLength: number,
                         maxLength: number,
                         entropyInput: number,
                         eiBytes: number): number => {
    if (this.entropyCallback === null) {
      throw new TypeError("Missing entropy callback.");
    }
    return this.entropyCallback(context,
                                minEntropy,
                                minLength,
                                maxLength,
                                entropyInput,
                                eiBytes);
  }

  /** The nonce callback for WASM. Calls the registered callback. */
  nonceCallbackWasm = (context: number,
                       minLength: number,
                       maxLength: number,
                       nonce: number,
                       nBytes: number): void => {
    if (this.nonceCallback === null) {
      throw new TypeError("Missing nonce callback.");
    }
    this.nonceCallback(context, minLength, maxLength, nonce, nBytes);
  }

  /** Timestamp callback for WASM. Calls the registered callback. */
  timestampCallbackWasm = (context: number, ts: number): void => {
    if (this.timestampCallback === null) {
      throw new TypeError("Missing timestamp callback.");
    }
    return this.timestampCallback(context, ts);
  }
}

/** A memory object usable by WASM and JS. */
export class MteMem {
  /** WASM memory offset. */
  public off: number;

  /** JS array overlaying the WASM memory. */
  public buff: Uint8Array | null;

  /** The amount of the JS array actually used. */
  public used: number;

  /** Constructor taking the WASM offset and overlaid array. The default
   *  arguments create an invalid memory object (like NULL). */
  constructor(o: number = -1, b: Uint8Array | null = null) {
    this.off = o;
    this.buff = b;
    this.used = b != null ? b.length : 0;
  }

  /* Invalidate this memory object. */
  invalidate = (): void => {
    this.off = -1;
    this.buff = null;
    this.used = 0;
  }
}

/** A heap block. */
class MteHeapBlock {
  /** True if the block is in use, false if not. */
  public inUse: boolean;

  /** The WASM memory offset. */
  public off: number;

  /** Byte length of the block. */
  public bytes: number;

  /** If the block is in use, the memory object that uses it. */
  public mteMem: MteMem | null;

  /** Constructor. The block is marked as not in use. */
  constructor(o: number, b: number) {
    this.inUse = false;
    this.off = o;
    this.bytes = b;
    this.mteMem = null;
  }
}


/** Signature of a WASM Kyber input callback. */
type MteKyberCallbackWasm = (
  /** Context. */
  context: number,

  /** Offset in WASM memory of the 32-bit offset in WASM memory of the provided
   *  array of the length given by maxEntropyBytes. The length is fixed. */
  entropy: number,

  /** Offset in WASM memory of the 32-bit length of the provided array on input;
   *  initially holds the same value as in maxEntropyBytes which equals the size
   *  of the provided buffer. The callback must set the 32-bit length of the
   *  actual entropy here. */
  entropyBytes: number,

  /** Offset in WASM memory of the 32-bit minimum entropy size;
   *  the value is for information only. It cannot be changed. */
  minEntropyBytes: number,

  /** Offset in WASM memory of the 32-bit maximum entropy size;
   *  the value is for information only. It cannot be changed. */
  maxEntropyBytes: number
) => number;

/** Signature of a WASM entropy input callback. */
type MteEntropyCallbackWasm = (
  /** Context. */
  context: number,

  /** The minimum entropy. */
  minEntropy: number,

  /** The minimum length in bytes. */
  minLength: number,

  /** The maximum length in bytes. */
  maxLength: number,

  /** Offset in WASM memory of the 32-bit offset in WASM memory of the provided
   *  array of length given by eiBytes. If larger entropy must be provided, WASM
   *  memory must be allocated and the 32-bit offset set to the offset of it. */
  entropyInput: number,

  /** Offset in WASM memory of the 32-bit length of the provided array on input;
   *  the callback must set the 32-bit length of the actual entropy here. */
  eiBytes: number
) => number;

/** Signature of a WASM nonce callback. */
type MteNonceCallbackWasm = (
  /** Context. */
  context: number,

  /** The minimum nonce length. */
  minLength: number,

  /** The maximum nonce length. */
  maxLength: number,

  /** Offset in WASM memory of the nonce array to write the nonce to. */
  nonce: number,

  /** Offset in WASM memory of the 32-bit nonce length. The callback must set
   *  this to the actual nonce length. */
  nBytes: number
) => void;

/** Signature of a WASM timestamp callback. */
type MteTimestampCallbackWasm = (
  /** Context. */
  context: number,

  /** Offset in WASM memory of the 64-bit timestamp. The callback must set this
   * to the timestamp value. */
  ts: number
) => void;

/** The WASM functions. */
interface MteWasmExports {
  /** WASM memory. */
  memory: WebAssembly.Memory;

  /** MTE WASM helper functions. */
  mte_wasm_base64_encode_bytes: (bytes: number) => number;
  mte_wasm_base64_encode: (data: number, bytes: number, buff: number) => void;
  mte_wasm_base64_decode: (buff: number) => number;

  /** MTE WASM base functions. */
  mte_base_version: () => number;
  mte_wasm_base_version_major: () => number;
  mte_wasm_base_version_minor: () => number;
  mte_wasm_base_version_patch: () => number;
  mte_wasm_base_status_count: () => number;
  mte_wasm_base_status_name: (status: MteStatus) => number;
  mte_wasm_base_status_description: (status: MteStatus) => number;
  mte_wasm_base_status_code: (name: number) => MteStatus;
  mte_base_status_is_error: (status: MteStatus) => boolean;
  mte_wasm_base_has_runtime_opts: () => boolean;
  mte_wasm_base_default_drbg: () => MteDrbgs;
  mte_wasm_base_default_tok_bytes: () => number;
  mte_wasm_base_default_verifiers: () => MteVerifiers;
  mte_wasm_base_default_cipher: () => MteCiphers;
  mte_wasm_base_default_hash: () => MteHashes;
  mte_wasm_base_drbgs_count: () => number;
  mte_wasm_base_drbgs_name: (algo: MteDrbgs) => number;
  mte_wasm_base_drbgs_algo: (name: number) => MteDrbgs;
  mte_wasm_base_drbgs_sec_strength_bytes: (algo: MteDrbgs) => number;
  mte_wasm_base_drbgs_personal_min_bytes: (algo: MteDrbgs) => number;
  mte_wasm_base_drbgs_personal_max_bytes: (algo: MteDrbgs) => number;
  mte_wasm_base_drbgs_entropy_min_bytes: (algo: MteDrbgs) => number;
  mte_wasm_base_drbgs_entropy_max_bytes: (algo: MteDrbgs) => number;
  mte_wasm_base_drbgs_nonce_min_bytes: (algo: MteDrbgs) => number;
  mte_wasm_base_drbgs_nonce_max_bytes: (algo: MteDrbgs) => number;
  mte_wasm_base_drbgs_reseed_interval: (algo: MteDrbgs) => number;
  mte_wasm_base_drbgs_incr_inst_error: (flag: boolean) => void;
  mte_wasm_base_drbgs_incr_gen_error: (flag: boolean, after: number) => void;
  mte_wasm_base_verifiers_count: () => number;
  mte_wasm_base_verifiers_name: (algo: MteVerifiers) => number;
  mte_wasm_base_verifiers_algo: (name: number) => MteVerifiers;
  mte_wasm_base_ciphers_count: () => number;
  mte_wasm_base_ciphers_name: (algo: MteCiphers) => number;
  mte_wasm_base_ciphers_algo: (name: number) => MteCiphers;
  mte_wasm_base_ciphers_block_bytes: (algo: MteCiphers) => number;
  mte_wasm_base_hashes_count: () => number;
  mte_wasm_base_hashes_name: (algo: MteHashes) => number;
  mte_wasm_base_hashes_algo: (name: number) => MteHashes;

  /** MTE WASM miscellaneous functions. */
  mte_init: (cb: number, context: number) => number;
  mte_license_init: (company: number, license: number) => boolean;

  /** MTE WASM dec functions. */
  mte_wasm_dec_state_bytes: (drbg: MteDrbgs,
                             tok_bytes: number,
                             verifiers: MteVerifiers) => number;
  mte_wasm_dec_state_init: (state: number,
                            drbg: MteDrbgs,
                            tok_bytes: number,
                            verifiers: MteVerifiers,
                            t_window: number,
                            s_window: number) => MteStatus;
  mte_wasm_dec_instantiate: (state: number,
                             ei_cb_context: number,
                             n_cb_context: number,
                             ps: number, ps_bytes: number) => MteStatus;
  mte_wasm_dec_reseed_counter: (state: number) => number;
  mte_dec_save_bytes: (state: number) => number;
  mte_wasm_dec_save_bytes_b64: (state: number) => number;
  mte_dec_state_save: (state: number, saved: number) => MteStatus;
  mte_wasm_dec_state_save_b64: (state: number, saved: number) => MteStatus;
  mte_dec_state_restore: (state: number, saved: number) => MteStatus;
  mte_wasm_dec_state_restore_b64: (state: number, saved: number) => MteStatus;
  mte_dec_buff_bytes: (state: number, encoded_bytes: number) => number;
  mte_wasm_dec_buff_bytes_b64: (state: number, encoded_bytes: number) => number;
  mte_wasm_dec_decode: (state: number,
                        t_cb_context: number,
                        encoded: number, encoded_bytes: number,
                        decoded: number,
                        decoded_off: number,
                        decoded_bytes: number,
                        enc_ts: number,
                        dec_ts: number,
                        msg_skipped: number) => MteStatus;
  mte_wasm_dec_decode_b64: (state: number,
                            t_cb_context: number,
                            encoded: number, encoded_bytes: number,
                            decoded: number,
                            decoded_off: number,
                            decoded_bytes: number,
                            enc_ts: number,
                            dec_ts: number,
                            msg_skipped: number) => MteStatus;
  mte_dec_uninstantiate: (state: number) => MteStatus;

  /** MTE WASM enc functions. */
  mte_wasm_enc_state_bytes: (drbg: MteDrbgs,
                             tok_bytes: number,
                             verifiers: MteVerifiers) => number;
  mte_wasm_enc_state_init: (state: number,
                            drbg: MteDrbgs,
                            tok_bytes: number,
                            verifiers: MteVerifiers) => MteStatus;
  mte_wasm_enc_instantiate: (state: number,
                             ei_cb_context: number,
                             n_cb_context: number,
                             ps: number, ps_bytes: number) => MteStatus;
  mte_wasm_enc_reseed_counter: (state: number) => number;
  mte_enc_save_bytes: (state: number) => number;
  mte_wasm_enc_save_bytes_b64: (state: number) => number;
  mte_enc_state_save: (state: number, saved: number) => MteStatus;
  mte_wasm_enc_state_save_b64: (state: number, saved: number) => MteStatus;
  mte_enc_state_restore: (state: number, saved: number) => MteStatus;
  mte_wasm_enc_state_restore_b64: (state: number, saved: number) => MteStatus;
  mte_enc_buff_bytes: (state: number, data_bytes: number) => number;
  mte_wasm_enc_buff_bytes_b64: (state: number, data_bytes: number) => number;
  mte_wasm_enc_encode: (state: number,
                        t_cb_context: number,
                        data: number, data_bytes: number,
                        encoded: number,
                        encoded_off: number,
                        encoded_bytes: number) => MteStatus;
  mte_wasm_enc_encode_b64: (state: number,
                            t_cb_context: number,
                            data: number,
                            data_bytes: number,
                            encoded: number,
                            encoded_off: number,
                            encoded_bytes: number) => MteStatus;
  mte_enc_uninstantiate: (state: number) => MteStatus;


  /** MTE WASM MKE dec functions. */
  mte_wasm_mke_dec_state_bytes: (drbg: MteDrbgs,
                                 tok_bytes: number,
                                 verifiers: MteVerifiers,
                                 cipher: MteCiphers,
                                 hash: MteHashes) => number;
  mte_wasm_mke_dec_state_init: (state: number,
                                drbg: MteDrbgs,
                                tok_bytes: number,
                                verifiers: MteVerifiers,
                                cipher: MteCiphers,
                                hash: MteHashes,
                                t_window: number,
                                s_window: number) => MteStatus;
  mte_wasm_mke_dec_instantiate: (state: number,
                                 ei_cb_context: number,
                                 n_cb_context: number,
                                 ps: number, ps_bytes: number) => MteStatus;
  mte_wasm_mke_dec_reseed_counter: (state: number) => number;
  mte_mke_dec_save_bytes: (state: number) => number;
  mte_wasm_mke_dec_save_bytes_b64: (state: number) => number;
  mte_mke_dec_state_save: (state: number, saved: number) => MteStatus;
  mte_wasm_mke_dec_state_save_b64: (state: number, saved: number) => MteStatus;
  mte_mke_dec_state_restore: (state: number, saved: number) => MteStatus;
  mte_wasm_mke_dec_state_restore_b64: (state: number,
                                       saved: number) => MteStatus;
  mte_mke_dec_buff_bytes: (state: number, encoded_bytes: number) => number;
  mte_wasm_mke_dec_buff_bytes_b64: (state: number,
                                    encoded_bytes: number) => number;
  mte_wasm_mke_dec_decode: (state: number,
                            t_cb_context: number,
                            encoded: number, encoded_bytes: number,
                            decoded: number,
                            decoded_off: number,
                            decoded_bytes: number,
                            enc_ts: number,
                            dec_ts: number,
                            msg_skipped: number) => MteStatus;
  mte_wasm_mke_dec_decode_b64: (state: number,
                                t_cb_context: number,
                                encoded: number, encoded_bytes: number,
                                decoded: number,
                                decoded_off: number,
                                decoded_bytes: number,
                                enc_ts: number,
                                dec_ts: number,
                                msg_skipped: number) => MteStatus;
  mte_mke_dec_decrypt_state_bytes: (state: number) => number;
  mte_mke_dec_decrypt_start: (state: number, c_state: number) => MteStatus;
  mte_wasm_mke_dec_decrypt_chunk: (state: number, c_state: number,
                                   encrypted: number, encrypted_bytes: number,
                                   decrypted: number,
                                   decrypted_bytes: number) => MteStatus;
  mte_wasm_mke_dec_decrypt_finish: (state: number, c_state: number,
                                    t_cb_context: number,
                                    decrypted_off: number,
                                    decrypted_bytes: number,
                                    enc_ts: number,
                                    dec_ts: number,
                                    msg_skipped: number) => MteStatus;
  mte_mke_dec_uninstantiate: (state: number) => MteStatus;

  /** MTE WASM MKE enc functions. */
  mte_wasm_mke_enc_state_bytes: (drbg: MteDrbgs,
                                 tok_bytes: number,
                                 verifiers: MteVerifiers,
                                 cipher: MteCiphers,
                                 hash: MteHashes) => number;
  mte_wasm_mke_enc_state_init: (state: number,
                                drbg: MteDrbgs,
                                tok_bytes: number,
                                verifiers: MteVerifiers,
                                cipher: MteCiphers,
                                hash: MteHashes) => MteStatus;
  mte_wasm_mke_enc_instantiate: (state: number,
                                 ei_cb_context: number,
                                 n_cb_context: number,
                                 ps: number, ps_bytes: number) => MteStatus;
  mte_wasm_mke_enc_reseed_counter: (state: number) => number;
  mte_mke_enc_save_bytes: (state: number) => number;
  mte_wasm_mke_enc_save_bytes_b64: (state: number) => number;
  mte_mke_enc_state_save: (state: number, saved: number) => MteStatus;
  mte_wasm_mke_enc_state_save_b64: (state: number, saved: number) => MteStatus;
  mte_mke_enc_state_restore: (state: number, saved: number) => MteStatus;
  mte_wasm_mke_enc_state_restore_b64: (state: number,
                                       saved: number) => MteStatus;
  mte_mke_enc_buff_bytes: (state: number, data_bytes: number) => number;
  mte_wasm_mke_enc_buff_bytes_b64: (state: number,
                                    data_bytes: number) => number;
  mte_wasm_mke_enc_encode: (state: number,
                            t_cb_context: number,
                            data: number, data_bytes: number,
                            encoded: number,
                            encoded_off: number,
                            encoded_bytes: number) => MteStatus;
  mte_wasm_mke_enc_encode_b64: (state: number,
                                t_cb_context: number,
                                data: number, data_bytes: number,
                                encoded: number,
                                encoded_off: number,
                                encoded_bytes: number) => MteStatus;
  mte_mke_enc_encrypt_finish_bytes: (state: number) => number;
  mte_mke_enc_encrypt_state_bytes: (state: number) => number;
  mte_mke_enc_encrypt_start: (state: number, c_state: number) => MteStatus;
  mte_wasm_mke_enc_encrypt_chunk: (state: number, c_state: number,
                                   data: number, data_bytes: number,
                                   encrypted: number) => MteStatus;
  mte_wasm_mke_enc_encrypt_finish: (state: number, c_state: number,
                                    t_cb_context: number,
                                    result_off: number,
                                    result_bytes: number) => MteStatus;
  mte_mke_enc_uninstantiate: (state: number) => MteStatus;


  /** MTE WASM Kyber functions. */
  mte_wasm_kyber_init: (strength: number) => number;
  mte_wasm_kyber_get_pubkey_size: () => number;
  mte_wasm_kyber_get_privkey_size: () => number;
  mte_wasm_kyber_get_secret_size: () => number;
  mte_wasm_kyber_get_encrypted_size: () => number;
  mte_wasm_kyber_get_min_entropy_size: () => number;
  mte_wasm_kyber_get_max_entropy_size: () => number;
  mte_wasm_kyber_get_algorithm: () => number;
  mte_wasm_kyber_create_keypair: (private_key: number,
                                  private_key_bytes: number,
                                  public_key: number,
                                  public_key_bytes: number,
                                  context: number) => number;
  mte_wasm_kyber_create_secret: (peer_public_key: number,
                                 peer_public_key_bytes: number,
                                 secret: number,
                                 secret_bytes: number,
                                 encrypted: number,
                                 encrypted_bytes: number,
                                 context: number) => number;
  mte_wasm_kyber_decrypt_secret: (private_key: number,
                                  private_key_bytes: number,
                                  encrypted: number,
                                  encrypted_bytes: number,
                                  secret: number,
                                  secret_bytes: number) => number;

}

/** Class to hold the WASM data. */
class MteWasmData {
  /** The WASM data in Base64. */
  static readonly wasmB64: string =
  "AGFzbQEAAAABnQEUYAJ/fwF/YAF/AX9gAAF/YAN/f38AYAJ/fwBgBX9/f39/AX9gA39/fwF/YAF/AGAEf39/fwBgB39/f39/f38Bf2ABfwF8YAp/f39/f39/f39/AX9gBn9/f39/fwF/YAV/f39/fwBgBH9/f38Bf2AGf39/fH9/AX9gAABgBn9/f398fwF/YAh/f39/f398fwF/YAh/f39/f39/fwF/AkIDA2Vudg5tdGVfd2FzbV9laV9jYgAPA2Vudg1tdGVfd2FzbV9uX2NiAA0DZW52EW10ZV93YXNtX2t5YmVyX2NiAAUDtwG1ARAAAgEBBQAEBgYGAwABBAYHBAMDDgQHAwAFBAQGAQQGCAYBAAAAAQYAAAAAAAABAQYAAAABAAAAAQEAAQAAAAEAAQQNBwMIAwMDCAcIAwMHAwMEBAcDBwMEBwcICAAEAQMBAgICAgEBAQICAgIBAQEBCgEKBwQBAQEBAQIBAQYRBQoBAAAACwsGDgUKAAAACQkFEgUAAAsLDBMFDAUAAAkJDAUBAgICAgICAgUFCQwDAAIHAQIEBQFwAQUFBQYBAQGAgAIGCAF/AUGQrQILB4ceggEGbWVtb3J5AgAIbXRlX2luaXQABBBtdGVfYmFzZV92ZXJzaW9uAAUZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEAGG10ZV9iYXNlX3N0YXR1c19pc19lcnJvcgAGEG10ZV9saWNlbnNlX2luaXQACRJtdGVfZW5jX3NhdmVfYnl0ZXMAJRJtdGVfZW5jX3N0YXRlX3NhdmUAJhVtdGVfZW5jX3N0YXRlX3Jlc3RvcmUAJxJtdGVfZW5jX2J1ZmZfYnl0ZXMAKBVtdGVfZW5jX3VuaW5zdGFudGlhdGUAKRJtdGVfZGVjX3NhdmVfYnl0ZXMAJRJtdGVfZGVjX3N0YXRlX3NhdmUALhVtdGVfZGVjX3N0YXRlX3Jlc3RvcmUALxJtdGVfZGVjX2J1ZmZfYnl0ZXMAMBVtdGVfZGVjX3VuaW5zdGFudGlhdGUAMRZtdGVfbWtlX2VuY19zYXZlX2J5dGVzACUWbXRlX21rZV9lbmNfc3RhdGVfc2F2ZQAmGW10ZV9ta2VfZW5jX3N0YXRlX3Jlc3RvcmUAOBZtdGVfbWtlX2VuY19idWZmX2J5dGVzADkgbXRlX21rZV9lbmNfZW5jcnlwdF9maW5pc2hfYnl0ZXMAOx9tdGVfbWtlX2VuY19lbmNyeXB0X3N0YXRlX2J5dGVzADwZbXRlX21rZV9lbmNfZW5jcnlwdF9zdGFydAA9GW10ZV9ta2VfZW5jX3VuaW5zdGFudGlhdGUAPhZtdGVfbWtlX2RlY19zYXZlX2J5dGVzACUWbXRlX21rZV9kZWNfc3RhdGVfc2F2ZQAuGW10ZV9ta2VfZGVjX3N0YXRlX3Jlc3RvcmUAPxZtdGVfbWtlX2RlY19idWZmX2J5dGVzAEAfbXRlX21rZV9kZWNfZGVjcnlwdF9zdGF0ZV9ieXRlcwBCGW10ZV9ta2VfZGVjX2RlY3J5cHRfc3RhcnQAQxltdGVfbWtlX2RlY191bmluc3RhbnRpYXRlAEQcbXRlX3dhc21fYmFzZTY0X2VuY29kZV9ieXRlcwBiFm10ZV93YXNtX2Jhc2U2NF9lbmNvZGUAYxZtdGVfd2FzbV9iYXNlNjRfZGVjb2RlAGQbbXRlX3dhc21fYmFzZV92ZXJzaW9uX21ham9yAGUbbXRlX3dhc21fYmFzZV92ZXJzaW9uX21pbm9yAGYbbXRlX3dhc21fYmFzZV92ZXJzaW9uX3BhdGNoAGcabXRlX3dhc21fYmFzZV9zdGF0dXNfY291bnQAaBltdGVfd2FzbV9iYXNlX3N0YXR1c19uYW1lAGkgbXRlX3dhc21fYmFzZV9zdGF0dXNfZGVzY3JpcHRpb24AahltdGVfd2FzbV9iYXNlX3N0YXR1c19jb2RlAGsebXRlX3dhc21fYmFzZV9oYXNfcnVudGltZV9vcHRzAGcabXRlX3dhc21fYmFzZV9kZWZhdWx0X2RyYmcAbB9tdGVfd2FzbV9iYXNlX2RlZmF1bHRfdG9rX2J5dGVzAG0fbXRlX3dhc21fYmFzZV9kZWZhdWx0X3ZlcmlmaWVycwBuHG10ZV93YXNtX2Jhc2VfZGVmYXVsdF9jaXBoZXIAbhptdGVfd2FzbV9iYXNlX2RlZmF1bHRfaGFzaABuGW10ZV93YXNtX2Jhc2VfZHJiZ3NfY291bnQAbxhtdGVfd2FzbV9iYXNlX2RyYmdzX25hbWUAcBhtdGVfd2FzbV9iYXNlX2RyYmdzX2FsZ28AcSZtdGVfd2FzbV9iYXNlX2RyYmdzX3NlY19zdHJlbmd0aF9ieXRlcwByJm10ZV93YXNtX2Jhc2VfZHJiZ3NfcGVyc29uYWxfbWluX2J5dGVzAHMmbXRlX3dhc21fYmFzZV9kcmJnc19wZXJzb25hbF9tYXhfYnl0ZXMAdCVtdGVfd2FzbV9iYXNlX2RyYmdzX2VudHJvcHlfbWluX2J5dGVzAHIlbXRlX3dhc21fYmFzZV9kcmJnc19lbnRyb3B5X21heF9ieXRlcwB0I210ZV93YXNtX2Jhc2VfZHJiZ3Nfbm9uY2VfbWluX2J5dGVzAHUjbXRlX3dhc21fYmFzZV9kcmJnc19ub25jZV9tYXhfYnl0ZXMAciNtdGVfd2FzbV9iYXNlX2RyYmdzX3Jlc2VlZF9pbnRlcnZhbAB2I210ZV93YXNtX2Jhc2VfZHJiZ3NfaW5jcl9pbnN0X2Vycm9yAHcibXRlX3dhc21fYmFzZV9kcmJnc19pbmNyX2dlbl9lcnJvcgB4HW10ZV93YXNtX2Jhc2VfdmVyaWZpZXJzX2NvdW50AG0cbXRlX3dhc21fYmFzZV92ZXJpZmllcnNfbmFtZQB5HG10ZV93YXNtX2Jhc2VfdmVyaWZpZXJzX2FsZ28AehttdGVfd2FzbV9iYXNlX2NpcGhlcnNfY291bnQAZRptdGVfd2FzbV9iYXNlX2NpcGhlcnNfbmFtZQB7Gm10ZV93YXNtX2Jhc2VfY2lwaGVyc19hbGdvAHwhbXRlX3dhc21fYmFzZV9jaXBoZXJzX2Jsb2NrX2J5dGVzAH0abXRlX3dhc21fYmFzZV9oYXNoZXNfY291bnQAfhltdGVfd2FzbV9iYXNlX2hhc2hlc19uYW1lAH8ZbXRlX3dhc21fYmFzZV9oYXNoZXNfYWxnbwCAARhtdGVfd2FzbV9kZWNfc3RhdGVfYnl0ZXMAgQEXbXRlX3dhc21fZGVjX3N0YXRlX2luaXQAggEYbXRlX3dhc21fZGVjX2luc3RhbnRpYXRlAIMBG210ZV93YXNtX2RlY19yZXNlZWRfY291bnRlcgCEARttdGVfd2FzbV9kZWNfc2F2ZV9ieXRlc19iNjQAhQEbbXRlX3dhc21fZGVjX3N0YXRlX3NhdmVfYjY0AIYBHm10ZV93YXNtX2RlY19zdGF0ZV9yZXN0b3JlX2I2NACHARttdGVfd2FzbV9kZWNfYnVmZl9ieXRlc19iNjQAiAETbXRlX3dhc21fZGVjX2RlY29kZQCJARdtdGVfd2FzbV9kZWNfZGVjb2RlX2I2NACKARhtdGVfd2FzbV9lbmNfc3RhdGVfYnl0ZXMAiwEXbXRlX3dhc21fZW5jX3N0YXRlX2luaXQAjAEYbXRlX3dhc21fZW5jX2luc3RhbnRpYXRlAI0BG210ZV93YXNtX2VuY19yZXNlZWRfY291bnRlcgCOARttdGVfd2FzbV9lbmNfc2F2ZV9ieXRlc19iNjQAhQEbbXRlX3dhc21fZW5jX3N0YXRlX3NhdmVfYjY0AI8BHm10ZV93YXNtX2VuY19zdGF0ZV9yZXN0b3JlX2I2NACQARttdGVfd2FzbV9lbmNfYnVmZl9ieXRlc19iNjQAkQETbXRlX3dhc21fZW5jX2VuY29kZQCSARdtdGVfd2FzbV9lbmNfZW5jb2RlX2I2NACTARxtdGVfd2FzbV9ta2VfZGVjX3N0YXRlX2J5dGVzAJQBG210ZV93YXNtX21rZV9kZWNfc3RhdGVfaW5pdACVARxtdGVfd2FzbV9ta2VfZGVjX2luc3RhbnRpYXRlAJYBH210ZV93YXNtX21rZV9kZWNfcmVzZWVkX2NvdW50ZXIAhAEfbXRlX3dhc21fbWtlX2RlY19zYXZlX2J5dGVzX2I2NACFAR9tdGVfd2FzbV9ta2VfZGVjX3N0YXRlX3NhdmVfYjY0AIYBIm10ZV93YXNtX21rZV9kZWNfc3RhdGVfcmVzdG9yZV9iNjQAlwEfbXRlX3dhc21fbWtlX2RlY19idWZmX2J5dGVzX2I2NACYARdtdGVfd2FzbV9ta2VfZGVjX2RlY29kZQCZARttdGVfd2FzbV9ta2VfZGVjX2RlY29kZV9iNjQAmgEebXRlX3dhc21fbWtlX2RlY19kZWNyeXB0X2NodW5rAJsBH210ZV93YXNtX21rZV9kZWNfZGVjcnlwdF9maW5pc2gAnAEcbXRlX3dhc21fbWtlX2VuY19zdGF0ZV9ieXRlcwCdARttdGVfd2FzbV9ta2VfZW5jX3N0YXRlX2luaXQAngEcbXRlX3dhc21fbWtlX2VuY19pbnN0YW50aWF0ZQCfAR9tdGVfd2FzbV9ta2VfZW5jX3Jlc2VlZF9jb3VudGVyAI4BH210ZV93YXNtX21rZV9lbmNfc2F2ZV9ieXRlc19iNjQAhQEfbXRlX3dhc21fbWtlX2VuY19zdGF0ZV9zYXZlX2I2NACPASJtdGVfd2FzbV9ta2VfZW5jX3N0YXRlX3Jlc3RvcmVfYjY0AKABH210ZV93YXNtX21rZV9lbmNfYnVmZl9ieXRlc19iNjQAoQEXbXRlX3dhc21fbWtlX2VuY19lbmNvZGUAogEbbXRlX3dhc21fbWtlX2VuY19lbmNvZGVfYjY0AKMBHm10ZV93YXNtX21rZV9lbmNfZW5jcnlwdF9jaHVuawCkAR9tdGVfd2FzbV9ta2VfZW5jX2VuY3J5cHRfZmluaXNoAKUBE210ZV93YXNtX2t5YmVyX2luaXQApgEebXRlX3dhc21fa3liZXJfZ2V0X3B1YmtleV9zaXplAKcBH210ZV93YXNtX2t5YmVyX2dldF9wcml2a2V5X3NpemUAqAEebXRlX3dhc21fa3liZXJfZ2V0X3NlY3JldF9zaXplAKkBIW10ZV93YXNtX2t5YmVyX2dldF9lbmNyeXB0ZWRfc2l6ZQCqASNtdGVfd2FzbV9reWJlcl9nZXRfbWluX2VudHJvcHlfc2l6ZQCrASNtdGVfd2FzbV9reWJlcl9nZXRfbWF4X2VudHJvcHlfc2l6ZQCsARxtdGVfd2FzbV9reWJlcl9nZXRfYWxnb3JpdGhtAK0BHW10ZV93YXNtX2t5YmVyX2NyZWF0ZV9rZXlwYWlyAK8BHG10ZV93YXNtX2t5YmVyX2NyZWF0ZV9zZWNyZXQAsAEdbXRlX3dhc21fa3liZXJfZGVjcnlwdF9zZWNyZXQAsQELX2luaXRpYWxpemUAAxBfX2Vycm5vX2xvY2F0aW9uALcBCXN0YWNrU2F2ZQC0AQxzdGFja1Jlc3RvcmUAtQEKc3RhY2tBbGxvYwC2AQkLAQBBAQsEYWCuAQMKztQEtQEDAAEL3wMBAn9B8CtBgAgtAAAiAgR/QQAhAANAIAIgA2ohAyAAIgFBAWoiAEGACGotAAAiAg0ACyABQQJqBUEBC0GACGoiAC0AQEEIdCAALQBBciIBIAAtAD8gAC0APiAALQA9IAAtADwgAC0AOyAALQA6IAAtADkgAC0AOCAALQA3IAAtADYgAC0ANSAALQA0IAAtADMgAC0AMiAALQAxIAAtADAgAC0ALyAALQAuIAAtAC0gAC0ALCAALQArIAAtACogAC0AKSAALQAoIAAtACcgAC0AJiAALQAlIAAtACQgAC0AIyAALQAiIAAtACEgAC0AICAALQAfIAAtAB4gAC0AHSAALQAcIAAtABsgAC0AGiAALQAZIAAtABggAC0AFyAALQAWIAAtABUgAC0AFCAALQATIAAtABIgAC0AESAALQAQIAAtAA8gAC0ADiAALQANIAAtAAwgAC0ACyAALQAKIAAtAAkgAC0ACCAALQAHIAAtAAYgAC0ABSAALQAEIAAtAAMgAC0AAiAALQABIAMgAC0AAGpqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqamprIAFFciIANgIAIABFCwUAQYAICycBAX8CQAJAIAAODwEAAAAAAAAAAAAAAAAAAQALIABBD0chAQsgAQuHBQIMfwJ+AkAgAEEIIABBQGsiCxAfIgENACAAQcgRakEAOgAAIABByABqIQlBgAEhA0GBASEEQQEhCANAIABBCCAJEB8iAQ0BIAMgBGohBgNAIAkpAwAhDSAGIQcgAyEFIAQhAgJAA0ACQCALIAAgB0EBdiIBakHIEGotAABBA3RqKQMAIg4gDVYEQCABIAVGBEAgBSECDAILIAEgBWohByABIQIMAgsgDSAOWA0CIAFBAWoiBSACTw0AIAIgBWohBwwBCwsCQAJAIANFDQAgAiADRw0AIAAgA0EBayIDakHIEGogCDoAAAwBCwJAAkAgAiAERw0AIAJBgAJGDQAgACAEakHIEGogCDoAAAwBCwJAIARBgAJHBEAgA0UNASACIANrIAQgAmtPDQELAkAgA0EBayIGIAJBAWsiCk8NAEEAIQUgBiEBIAIgA2tBA3EiDARAA0AgAEHIEGoiByABaiAHIAFBAWoiAWotAAA6AAAgBUEBaiIFIAxHDQALCyACIANBf3NqQQNJDQADQCAAIAFqIgJByBBqIAJByRBqKAAANgAAIAFBBGoiASAKRw0ACwsgACAKakHIEGogCDoAACAGIQMMAgsCQCACIARPDQBBACEFIAQiASACa0EDcSIHBEADQCAAQcgQaiIGIAFqIAYgAUEBayIBai0AADoAACAFQQFqIgUgB0cNAAsLIAQgAkF/c2pBA0kNAANAIABByBBqIgYgAWpB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BSAGaiABIAVqLQAAOgAAIAVBAWohBSADQQFqIgMgAEcNAAsLIAIgBGoPC0EAIQRBACEFIAJBAWtBA08EQCACQXxxIQZBACEAA0AgAyAFaiABIAVqLQAAOgAAIAMgBUEBciIHaiABIAdqLQAAOgAAIAMgBUECciIHaiABIAdqLQAAOgAAIAMgBUEDciIHaiABIAdqLQAAOgAAIAVBBGohBSAAQQRqIgAgBkcNAAsLIAJBA3EiAARAA0AgAyAFaiABIAVqLQAAOgAAIAVBAWohBSAEQQFqIgQgAEcNAAsLIAILvgQAIAEgACkDMDwAACABIAApAzBCCIg8AAEgASAAKQMwQhCIPAACIAEgACkDMEIYiDwAAyABIAA1AjQ8AAQgASAAKQMwQiiIPAAFIAEgADMBNjwABiABIAAxADc8AAcgASAALQAAOgAIIAEgAC0AAToACSABIAAtAAI6AAogASAALQADOgALIAEgAC0ABDoADCABIAAtAAU6AA0gASAALQAGOgAOIAEgAC0ABzoADyABIAAtAAg6ABAgASAALQAJOgARIAEgAC0ACjoAEiABIAAtAAs6ABMgASAALQAMOgAUIAEgAC0ADToAFSABIAAtAA46ABYgASAALQAPOgAXIAEgAC0AEDoAGCABIAAtABE6ABkgASAALQASOgAaIAEgAC0AEzoAGyABIAAtABQ6ABwgASAALQAVOgAdIAEgAC0AFjoAHiABIAAtABc6AB8gASAALQAYOgAgIAEgAC0AGToAISABIAAtABo6ACIgASAALQAbOgAjIAEgAC0AHDoAJCABIAAtAB06ACUgASAALQAeOgAmIAEgAC0AHzoAJyABIAAtACA6ACggASAALQAhOgApIAEgAC0AIjoAKiABIAAtACM6ACsgASAALQAkOgAsIAEgAC0AJToALSABIAAtACY6AC4gASAALQAnOgAvIAEgAC0AKDoAMCABIAAtACk6ADEgASAALQAqOgAyIAEgAC0AKzoAMyABIAAtACw6ADQgASAALQAtOgA1IAEgAC0ALjoANiABIAAtAC86ADcL7AMAIAAgASkAADcDMCAAIAEtAAg6AAAgACABLQAJOgABIAAgAS0ACjoAAiAAIAEtAAs6AAMgACABLQAMOgAEIAAgAS0ADToABSAAIAEtAA46AAYgACABLQAPOgAHIAAgAS0AEDoACCAAIAEtABE6AAkgACABLQASOgAKIAAgAS0AEzoACyAAIAEtABQ6AAwgACABLQAVOgANIAAgAS0AFjoADiAAIAEtABc6AA8gACABLQAYOgAQIAAgAS0AGToAESAAIAEtABo6ABIgACABLQAbOgATIAAgAS0AHDoAFCAAIAEtAB06ABUgACABLQAeOgAWIAAgAS0AHzoAFyAAIAEtACA6ABggACABLQAhOgAZIAAgAS0AIjoAGiAAIAEtACM6ABsgACABLQAkOgAcIAAgAS0AJToAHSAAIAEtACY6AB4gACABLQAnOgAfIAAgAS0AKDoAICAAIAEtACk6ACEgACABLQAqOgAiIAAgAS0AKzoAIyAAIAEtACw6ACQgACABLQAtOgAlIAAgAS0ALjoAJiAAIAEtAC86ACcgACABLQAwOgAoIAAgAS0AMToAKSAAIAEtADI6ACogACABLQAzOgArIAAgAS0ANDoALCAAIAEtADU6AC0gACABLQA2OgAuIAAgAS0ANzoALwuAAwEFfyMAQYACayIEJAACf0EDIAFBgIAESw0AGiAAKQMwQoGAgICAgMAAWgRAIABCADcDACAAQgA3AzAgAEIANwMoIABCADcDICAAQgA3AxggAEIANwMQIABCADcDCEEFDAELIAQgAEEQaiIGEBEgAUEQTwRAA0AgABAZIAQgACACEBIaIAJBEGohAiABQRBrIgFBD0sNAAsLAkAgAUUNACAAEBkgBCAAIARB8AFqEBIaIAFBAWshBSABQQNxIgcEQANAIAIgAUEBayIBaiAEQfABaiABai0AADoAACADQQFqIgMgB0cNAAsLIAVBA0kNAANAIAIgAUEBayIDaiAEQfABaiIFIANqLQAAOgAAIAIgAUECayIDaiAEQfABaiADai0AADoAACACIAFBA2siA2ogBEHwAWogA2otAAA6AAAgAiABQQRrIgFqIAEgBWotAAA6AAAgAQ0ACwtB0CUgBiAAEBogACAAKQMwQgF8NwMwQQALIQMgBEGAAmokACADCzUAIABCADcDACAAQgA3AzAgAEIANwMoIABCADcDICAAQgA3AxggAEIANwMQIABCADcDCEEAC5xFAUV/An8gAUEDcUUEQCABKAI8IgNBGHQgA0EIdEGAgPwHcXIgA0EIdkGA/gNxIANBGHZyciEDIAEoAjgiBEEYdCAEQQh0QYCA/AdxciAEQQh2QYD+A3EgBEEYdnJyIQQgASgCNCICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIhEyABKAIwIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciEUIAEoAiwiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIRUgASgCKCICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIhFiABKAIkIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciEXIAEoAiAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIRggASgCHCICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIhGSABKAIYIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciEcIAEoAhQiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIR0gASgCECICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIhDCABKAIMIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciEJIAEoAggiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIQ8gASgCBCICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIhCiABKAIAIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycgwBCyABKAA8IgNBGHQgA0EIdEGAgPwHcXIgA0EIdkGA/gNxIANBGHZyciEDIAEoADgiBEEYdCAEQQh0QYCA/AdxciAEQQh2QYD+A3EgBEEYdnJyIQQgASgANCICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIhEyABKAAwIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciEUIAEoACwiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIRUgASgAKCICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIhFiABKAAkIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciEXIAEoACAi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IAAgAWogACADai0AADoAACABIABBAXIiCmogAyAKai0AADoAACABIABBAnIiCmogAyAKai0AADoAACABIABBA3IiCmogAyAKai0AADoAACAAQQRqIQAgB0EEaiIHIAVHDQALCyAJQQNxIgdFDQADQCAAIAFqIAAgA2otAAA6AAAgAEEBaiEAIARBAWoiBCAHRw0ACwsgCEH//wNxIgBBkCwtAAAiA0kEQCAAIAFqIAhBf3MgA2pB//8DcUEBahCzARoLIAhBgQJPBEAgBigCGCEEQYACIQBBgAIhBwNAIAEgAEH/AXFqIgUgBS0AACAAIARqLQAAczoAACAIIAdBAWoiB0H//wNxIgBLDQALCwJAIANFDQBBACEHQQAhACADQQFrQQNPBEAgA0H8AXEhCEEAIQQDQCAAIAFqIgUgBS0AACAAQQFyIgVBkCxqLQAAczoAACABIAVqIgUgBS0AACAAQQJyIgVBkCxqLQAAczoAACABIAVqIgUgBS0AACAAQQNyIgVBkCxqLQAAczoAACABIAVqIgUgBS0AACAAQQRqIgBBkCxqLQAAczoAACAEQQRqIgQgCEcNAAsLIANBA3EiBEUNAANAIAAgAWoiCCAILQAAIABBAWoiAEGQLGotAABzOgAAIAdBAWoiByAERw0ACwsgAiABNgIYIAIgCSADIAMgCUkbNgIcIAsgAkEIahA0IgANACALQQI2AoQWCyACQSBqJAAgBkEgaiQAIAALdAEDfyMAIgIhAyACIAEQECIEQQNqQQJ2QQNsQRBqQXBxayICJAAgASAEIAIQDBoCQAJ/IABBD2pBcHEiASgChBZBBGtBfUkEQEEBIQBBAAwBCyABIAIQNiIADQFBACEAQQILIQIgASACNgKEFgsgAyQAIAALKABBDyABQQNqQQJ2QQNsQQFqIgBB4AFrIABBhQJJGyAAQQ9qQXBxagtuACMAQRBrIgEkACABIAM2AgwgASACNgIEIAFBADYCACABIAQ2AgggACABEEEhACAFIAEoAgggBGtBACABKAIMIgIbNgIAIAYgAjYCACAHQgA3AwAgCEIANwMAIAkgASgCADYCACABQRBqJAAgAAucAQAjAEEQayIBJAAgASADNgIMIAEgAjYCBCABQQA2AgAgASAENgIIIAEgASgCBCABKAIMIAEoAggQDCICNgIMIAEgASgC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ASAENgIEIAAgARA6IQAgBSABKAIEIARrQQAgASgCCCICGzYCACAGIAI2AgAgAUEQaiQAIAALiwEAIwBBEGsiASQAIAEgAzYCCCABIAI2AgAgASAENgIEAn8gACABEDoiAARAIAFBADYCCCAADAELIAEoAgQiAiABKAIIIgMgAiADaiICEAshAyABIAI2AgQgASADNgIIIAALIQAgBSABKAIEIARrQQAgASgCCCICGzYCACAGIAI2AgAgAUEQaiQAIAALkAUBBn8jAEEQayIGJAAgBiADNgIIIAYgBDYCBCAGIAI2AgACfyAGKAIEIQcgAEEPakFwcSILKAKAFkEDRwRAIAcgBigCCBAKQQEMAQsgC0GAFWogBigCACAGKAIIECQhCSAGKAIIIQACQCAGKAIAIgggAUEPakFwcSIEKAKAAiICckEHcUUEQCACQQN2IQJBACEDIABBCE8EQCALQeASaiEKA0AgBCACQQN0aiIBIAEpAwAgCCADQQN0aikDAIU3AwAgAkEBaiICQSBHBH8gA0EBagVBACECIAogBCAEKAKAAiIBakGAAiABayIBIAcQFyEDIARBADYCgAIgAyAJciEJIAEgB2ohByAIIAFBeHFqIQhBAAshAyAAQQhrIgBBB0sNAAsLIAJBA3QhAiAARQ0BIANBA3QhAyAAQQFxBH8gAiAEaiIBIAEtAAAgAyAIai0AAHM6AAAgA0EBciEDIAJBAXIhAiAAQQFrBSAACyEBIABBAUYNAQNAIAIgBGoiACAALQAAIAMgCGoiCi0AAHM6AAAgACAALQABIAotAAFzOgABIANBAmohAyACQQJqIQIgAUECayIBDQALDAELIABFDQAgC0HgEmohCkEAIQMDQCACIARqIgEgAS0AACADIAhqLQAAczoAACACQQFqIgJBgAJHBH8gA0EBagVBACECIAogBCAEKAKAAiIBakGAAiABayIBIAcQFyEDIARBADYCgAIgAyAJciEJIAEgCGohCCABIAdqIQdBAAshAyAAQQFrIgANAAsLIAtB4BJqIAQgBCgCgAIiAGogAiAAayIAIAcQFyEBIAQgBCgCgAIgAGo2AoACIAEgCXILIQAgBSAGKAIINgIAIAZBEGokACAAC7gBAQF/IwBBEGsiAiQAIAJCADcDACACQQA2AggCf0EKQYAsKAIARQ0AGiAAQQ9q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bXBsX2Vycm9yAG10ZV9zdGF0dXNfZHJiZ19lcnJvcgBtdGVfc3RhdHVzX2xpY2Vuc2VfZXJyb3IAbXRlX3ZlcmlmaWVyc19zZXEAbXRlX3N0YXR1c19kaWdlc3RfbWlzbWF0Y2gAbXRlX3N0YXR1c19zZXFfbWlzbWF0Y2gAbXRlX3N0YXR1c19jaGVja3N1bV9taXNtYXRjaABtdGVfZHJiZ3NfY3RyX2FlczI1Nl9kZgBtdGVfc3RhdHVzX3Vuc3VwcG9ydGVkAG10ZV9zdGF0dXNfb3V0cHV0X2luaGliaXRlZABtdGVfc3RhdHVzX2NpcGhlcl90ZXN0X2ZhaWxlZABtdGVfc3RhdHVzX2hhc2hfdGVzdF9mYWlsZWQAbXRlX3N0YXR1c19kcmJnX3NlZWRsaWZlX3JlYWNoZWQAbXRlX3N0YXR1c190aW1lX2FmdGVyX2V4Y2VlZGVkAG10ZV9zdGF0dXNfdGltZV9iZWZvcmVfZXhjZWVkZWQAbXRlX3N0YXR1c19kcmJnX2NhdGFzdHJvcGhpYwBLeWJlcjc2OABtdGVfaGFzaGVzX3NoYTI1NgBLeWJlcjEwMjQAS3liZXI1MTIAVGhlIHNlcXVlbmNlIG51bWJlciBpcyBvdXRzaWRlIHRoZSB3aW5kb3cuAE91dHB1dCBpcyBpbmhpYml0ZWQgZHVlIHRvIGFuIGVycm9yIHN0YXRlIG9yIHNlbGYtdGVzdC4AVGhlIG1lc3NhZ2Ugd2FzIHJlY2VpdmVkIHRvbyBsb25nIGFmdGVyIGl0IHdhcyBzZW50LgBUaGUgbWVzc2FnZSB3YXMgcmVjZWl2ZWQgdG9vIGxvbmcgYmVmb3JlIGl0IHdhcyBzZW50LgBObyBzdWNoIHRva2VuIGV4aXN0cy4ASW1wbGVtZW50YXRpb24gZXJyb3IuAEhhc2ggZGlnZXN0IG1pc21hdGNoLgBDaGVja3N1bSBtaXNtYXRjaC4AVGhlIHNlcXVlbmNlIG51bWJlciBoYXMgYWxyZWFkeSBiZWVuIHNlZW4gaW4gYXN5bmMgbW9kZS4AVGhlIGxpY2Vuc2Ugd2FzIG5vdCBzZXQgb3IgaXMgbm90IHZhbGlkLgBBbiBpbnB1dCB3YXMgbm90IHZhbGlkLgBBdHRlbXB0aW5nIHRvIHN5bmMgdXAgYSBzZXF1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AAmAAIAAAAAACgAAgAAAAACLgACAAAAAAIsAAAAAAACAiYAAAAAAAIADgAAAAAAAgAKAAAAAAACAgAAAAAAAAIAKgAAAAAAAAAoAAIAAAACAgYAAgAAAAICAgAAAAAAAgAEAAIAAAAAACIAAgAAAAIDtCAsKmgsUB9UFjgUfAcoAVgxuAikGtgDCA08IPwe8BT0C1AcIAX8BxAmyBb8GfwxYCvkD3AJgAvsGmwE0DN4GxwSMAtkK9wP0B9MF5wv5BgQC+QzBC2cKrwZ3CH4AvQWsCacM8gs+A2sAdAcKDEoJcwvBAx0HLArAAdgIpQIGCLIIrgErAksDHghnAw4GaQCmAUsCsQAWDN4LNQsmBnUGCwwKA4cEbgz4CcsFpwpfBMsGhAKZCV0BogFJAWUMtgwxA0kEWwJiAioF/AdIB4ABQgh5DMIEygeXCdwAXgiGBmAIBwcDCBoDGwerCZsJ3gGVDM0L5APfA74DTQfyBVwGpQYPB7QFQwkiCR0JNAFsACMLZgNWA+YF5wn+BPoFoQR7BqMEJQxqAzcFPwiIAL8EgQu5BQUF1wefCqYKuAjQCUsAnAC4C18LpAtoA30KNgaiCFoCNgcJA5MAegj3CfYAjAbbBswBIwHrAFAMtgpbC5gM8waaCeMEtgnWClMLTwT7BFwKKQRBC9UC5AVACY4BtwP3AI0FlgzDCQ8BWgBVA0QHgwyKBFIGmgJAAQgA/QoIBhoBLgcNBQoJKAJ1CjoIIwbNAGYLBgahCiUKCAmpAoIAQgZPBz0Dggv5Cy0FxApFB8IFsgQ/CUsM2AaTCqsANwziC3MHLAftBWcB9gKhBQBB8CsLAQE=";

  /** The WASM data in a Uint8Array for WebAssembly instantiation. */
  readonly wasmArr: Uint8Array;

  /** Constructor. */
  constructor() {
    // Calculate the decoded length.
    let decBytes = Math.floor(MteWasmData.wasmB64.length / 4) * 3;
    for (let i = MteWasmData.wasmB64.length - 1; i > 0; --i) {
      if (MteWasmData.wasmB64[i] == "=") {
        --decBytes;
      }
      else {
        break;
      }
    }

    // Allocate an array to hold the decoded WASM data.
    this.wasmArr = new Uint8Array(decBytes);

    // Map the Base64 value.
    const mapB64 = (byte: number) => {
      if (byte >= 0x41 && byte <= 0x5A) { return byte - 0x41; }
      if (byte >= 0x61 && byte <= 0x7A) { return byte - 71; }
      if (byte >= 0x30 && byte <= 0x39) { return byte + 4; }
      if (byte == 0x2B) { return 62; }
      return 63;
    };

    // Convert the Base64 to bytes (possibly except a pad quad at the end).
    let b0;
    let b1;
    let b2;
    let b3;
    let b0ch;
    let b1ch;
    let b2ch;
    let b3ch;
    let binIndex = 0;
    let b64Index = 0;
    const noPad = Math.floor(decBytes / 3) * 3;
    while (binIndex < noPad) {
      // Get the quad.
      b0ch = MteWasmData.wasmB64.charCodeAt(b64Index); ++b64Index;
      b1ch = MteWasmData.wasmB64.charCodeAt(b64Index); ++b64Index;
      b2ch = MteWasmData.wasmB64.charCodeAt(b64Index); ++b64Index;
      b3ch = MteWasmData.wasmB64.charCodeAt(b64Index); ++b64Index;

      // Get the mapped value for each.
      b0 = mapB64(b0ch);
      b1 = mapB64(b1ch);
      b2 = mapB64(b2ch);
      b3 = mapB64(b3ch);

      // Assemble the 3 bytes from the quad values.
      this.wasmArr[binIndex] = ((b0       ) << 2) | (b1 >> 4); ++binIndex;
      this.wasmArr[binIndex] = ((b1 & 0x0F) << 4) | (b2 >> 2); ++binIndex;
      this.wasmArr[binIndex] = ((b2 & 0x03) << 6) | (b3     ); ++binIndex;
    }

    // Convert the padded quad.
    switch (decBytes - binIndex) {
      case 1:
        b0ch = MteWasmData.wasmB64.charCodeAt(b64Index); ++b64Index;
        b1ch = MteWasmData.wasmB64.charCodeAt(b64Index);
        b0 = mapB64(b0ch);
        b1 = mapB64(b1ch);
        this.wasmArr[binIndex] = ((b0       ) << 2) | (b1 >> 4);
        break;

      case 2:
        b0ch = MteWasmData.wasmB64.charCodeAt(b64Index); ++b64Index;
        b1ch = MteWasmData.wasmB64.charCodeAt(b64Index); ++b64Index;
        b2ch = MteWasmData.wasmB64.charCodeAt(b64Index);
        b0 = mapB64(b0ch);
        b1 = mapB64(b1ch);
        b2 = mapB64(b2ch);
        this.wasmArr[binIndex] = ((b0       ) << 2) | (b1 >> 4); ++binIndex;
        this.wasmArr[binIndex] = ((b1 & 0x0F) << 4) | (b2 >> 2);
        break;
    }
  }
}

